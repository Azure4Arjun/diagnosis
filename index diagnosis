 
---spDetectIndexFragmentation
--select db_id()

--CREATE TABLE sqlIndexREBUILD (
--	id int IDENTITY(1,1) NOT NULL PRIMARY KEY,
--	SQLString varchar(200) NOT NULL,
--	Fraglevel Decimal(19,3) NOT NULL,
--)
--GO
--CREATE PROCEDURE dbo.spDetectIndexFragmentation
--AS
--
--INSERT INTO sqlIndexRebuild (SQLString, FragLevel)
SELECT DISTINCT
	SQL_Reorg = 'ALTER INDEX ALL ON ' + x.dbname + '.' + x.schemaname + '.' + x.[table] + ' REORGANIZE' + CHAR(10)+ CHAR(13)+'GO'
,	SQL_Status = 'UPDATE STATISTICS ' + x.dbname + '.' + x.schemaname + '.' + x.[table]  + CHAR(10)+ CHAR(13)+'GO'
,	SQL_Rebuild = 'ALTER INDEX ALL ON ' + x.dbname + '.' + x.schemaname + '.' + x.[table] + ' REBUILD ' + CHAR(10)+ CHAR(13)+'GO'
--,	FragLevel	=	sum(FragLevel)
,	avg_fragmentation_in_percent	=	avg(avg_fragmentation_in_percent)
,	page_count	=	sum(page_count)
--, * 
FROM 
(
select 
	--[fraglevel] = (power(s.avg_fragmentation_in_percent,2) *page_count)/power(10,7),
	avg_fragmentation_in_percent = s.avg_fragmentation_in_percent
,	page_count = page_count
,	dbname		= db_name(s.database_id)
,	[table]		= o.name
,	schemaname	= sc.name
--, index_name = i.name, s.index_type_desc, alloc_unit_type_desc, s.avg_fragmentation_in_percent, page_count, fragment_count, avg_fragment_size_in_pages
--select *
from sys.dm_db_index_physical_stats (DB_ID(),null,null, null,'limited') s
inner join --select * from
sys.indexes i on s.object_id = i.object_id and s.index_id = i.index_id
inner join  --select * from
sys.objects o on o.object_id = s.object_id
inner join --select * from
sys.schemas sc
on o.schema_id = sc.schema_id

WHERE 
		i.is_disabled = 0
and		i.type_desc = 'CLUSTERED'
and		s.database_id = db_id()
and		alloc_unit_Type_desc <> 'LOB_DATA'
and page_count > 1000

) x
WHERE avg_fragmentation_in_percent > 70
group by x.dbname , x.schemaname , x.[table]
order by page_count desc, avg_fragmentation_in_percent desc

GO




--index ALLOW_PAGE_LOCKS
select 'alter INDEX [' + i.name + '] ON [' + s.name + '].[' + o.name + '] SET (ALLOW_PAGE_LOCKS = ON) --this is default'
, * from sys.indexes i
inner join sys.objects o on i.object_id  = o.object_id
inner join sys.schemas s on s.schema_id = o.schema_id
where allow_page_locks = 0
and o.is_ms_shipped = 0


-----------------------------------------------------------------------------------------------------------------------

--Index/partitions in current database
select SizeMb= (p.in_row_reserved_page_count*8.)/1024.
,	indexname = i.name
,	tablename = '[' + s.name + '].[' + o.name + ']'
,	pr.data_compression_desc
,	p.partition_number
,  rebuildcompress = 
CASE WHEN pr.data_compression_desc = 'columnstore' THEN NULL ELSE
	'ALTER INDEX [' + i.name + '] ON [' + s.name + '].[' + o.name + '] REBUILD ' + 
	CASE WHEN MAX(p.partition_number) OVER (PARTITION by i.name)  > 1 THEN 
	'PARTITION = ' + cast(p.partition_number as varchar(5)) ELSE ''  END +
	' WITH (SORT_IN_TEMPDB = ON
	, DATA_COMPRESSION = PAGE) ' + CHAR(10) + CHAR(13)
END
, *
from sys.dm_db_partition_stats p
inner join sys.partitions pr on p.partition_id = pr.partition_id
inner join sys.objects o on p.object_id = o.object_id 
inner join sys.schemas s on s.schema_id = o.schema_id
left outer join sys.indexes i on i.object_id = o.object_id and i.index_id = p.index_id
WHERE o.is_ms_shipped = 0

order by SizeMb desc



-----------------------------------------------------------------------------------------------------------------------
select 
	[Database Name] = db_name()
,	[Table Name]	= s.name + '.' + o.name
,	[Column Name]	= c.name
,	[Total_rows]	= sum(ps.row_count) 
--Review the distribution of the data in the table
,	[TSQL_Testing_Row_Distribution]	= 'select [' + c.name + '], count(1) from ['+ s.name + '].[' + o.name+'] group by [' + c.name + ']' 
from 
	sys.objects  o
inner join 
	sys.schemas s
	on o.schema_id = s.schema_id
inner join 
	sys.dm_db_partition_stats ps
	on ps.object_id = o.object_id
	and index_id <= 1 --heap or cluster index, ignore NC indexes

left outer join 
	sys.columns c on c.object_id = o.object_id 
left outer join 
	sys.types t on c.user_type_id = t.user_type_id
WHERE 
	o.name <> 'dtproperties'
and is_ms_shipped = 0
and o.type = 'u'
and (	c.name like 'is%' 
	or	c.name like '%active%' 
	or	c.name like '%ignore%' 
	or	c.name like 'has%'
	or	c.name like '%current%' 
	or	c.name like '%archived%' 
	or	c.name like '%flag%' 
	or	c.name like '%bit%' 
	or	t.name = 'bit' 
	--Add any more known naming conventions here
	)	
group by c.name, s.name, o.name
having sum(ps.row_count) > 100000
order by [Total_rows] desc
go

--Existing filtered indexes
SELECT 
	[Database Name] = db_name()
,	[Table Name]	= s.name + '.' + o.name
,	[Index Name]	= i.name
from 
	sys.objects  o
inner join 
	sys.schemas s
	on o.schema_id = s.schema_id
inner join 
	sys.indexes i
	on i.object_id = o.object_id
inner join 
	sys.dm_db_partition_stats ps
	on ps.object_id = o.object_id and ps.index_id = i.index_id
WHERE
	i.has_filter = 1
ORDER BY
	s.name, o.name, i.name


/*
--Potential Filtered index opportunities
select iscurrentphase, count(1) from RepairOrderRepairPhases group by IsCurrentPhase
select isEnabled, count(1) from dbo.Users group by IsEnabled
select [ISPUBLIC], count(1) from [dbo].[TNOTE] group by [ISPUBLIC]
--Potential filtered index
CREATE INDEX IDX_NC_F_Testing on dbo.testtable (Whatever1, whatever2) INCLUDE (whatever3)
WHERE IsActive = 1;
*/

---------------------------------------------------------------------------------------------------------------------
--Finds objects to drop that the Database Tuning Advisor (DTA) leaves behind when it inevitably crashes.

SELECT 'drop index [' + i.name+ '] on [' + schema_name(o.schema_id) + '].[' + object_name(i.[object_id]) + ']'
FROM sys.indexes i
INNER JOIN sys.objects o
ON i.object_id = o.object_id
WHERE 1=1 
and o.is_ms_shipped = 0
and o.type = 'u'
and i.name is not null
and i.is_hypothetical = 1 

select 'drop statistics [' + schema_name(o.schema_id) + '].[' + object_name(i.[object_id]) + '].['+ i.[name] + ']'
FROM sys.stats i
inner join sys.objects o 
on i.object_id = o.object_id 
WHERE 1=1
and o.is_ms_shipped = 0
and o.type = 'u'
and i.[name] LIKE '_dta%' 

---------------------------------------------------------------------------------------------------------------------
--Find duplicate indexes based on keysets and properties

SELECT TableName, IndexName1, IndexName2
, Idx_counter, Idx_first_counter, Keyset_counter, SizeMb
,  [Drop_TSQL] = CASE	WHEN y.Idx_counter > 1 and Idx_first_counter = 1 
	THEN 'IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''' + TableName + ''') AND name = N''' + IndexName1 + ''')
							DROP INDEX [' + IndexName1 + '] ON ' + TableName + ';' 
	ELSE '' END
FROM (
	SELECT  TableName, IndexName1, IndexName2, SizeMb
		,	Idx_counter = row_number() OVER (PARTITION BY TableName, IndexDefinition1 order by IndexName1, IndexName2)
		,	Idx_first_counter = row_number() OVER (PARTITION BY IndexName1 ORDER BY IndexName1, TableName)
		,	Keyset_counter = dense_rank() OVER ( ORDER BY IndexDefinition1)
		FROM (
			SELECT 
			  TableName = '[' + sc.name + '].[' + o.name + ']'
			, IndexName1 = i1.name, IndexName2 = i2.name
			, IndexDefinition1= (select tablename = object_name(ic.object_id), --indexname = i.name, 
					columnname = c.name,  is_descending_key = ic.is_descending_key, i.type_desc, is_included_column = ic.is_included_column, is_primary_key = i.is_primary_key, is_unique = i.is_unique, has_filter = i.has_filter, filter_definition  = isnull(filter_definition,'') from sys.index_columns ic
					inner join sys.indexes i on i.index_id = ic.index_id and i.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i1.index_id and ic.object_id = o.object_id and i.index_id > 1
					FOR XML AUTO) 
			, IndexDefinition2= (select tablename = object_name(ic.object_id), --indexname = i.name, 
					columnname = c.name, is_descending_key = ic.is_descending_key, i.type_desc, is_included_column = ic.is_included_column, is_primary_key = i.is_primary_key, is_unique = i.is_unique, has_filter = i.has_filter, filter_definition  = isnull(filter_definition,'') from sys.index_columns ic
					inner join sys.indexes i on i.index_id = ic.index_id and i.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i2.index_id and ic.object_id = o.object_id and i.index_id > 1
					FOR XML AUTO)
			, SizeMb= (p.in_row_reserved_page_count*8.)/1024.
			from sys.indexes i1 
			inner join sys.indexes i2
			on i1.object_id  = i2.object_id 
			inner join sys.objects o 
			on i1.object_id = o.object_id
			inner join sys.schemas sc
			on sc.schema_id = o.schema_id
			inner join sys.dm_db_partition_stats p
			on p.object_id = o.object_id
			and p.index_id = i1.index_id 
			WHERE 
				i1.name <> i2.name
			and i1.index_id <> i2.index_id
			and (
				UPPER(i1.name) = UPPER(i2.name) 
				or 
				(
					(select tablename = object_name(ic.object_id), columnname = c.name, si.type_desc, is_descending_key = ic.is_descending_key, is_included_column = ic.is_included_column, is_primary_key = si.is_primary_key, is_unique = si.is_unique, has_filter = si.has_filter, filter_definition  = isnull(filter_definition,'')
					from sys.index_columns ic
					inner join sys.indexes si on si.index_id = ic.index_id and si.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i1.index_id and ic.object_id = o.object_id and si.index_id > 1
					FOR XML AUTO)
					= 
					(select tablename = object_name(ic.object_id), columnname = c.name, si.type_desc, is_descending_key = ic.is_descending_key, is_included_column = ic.is_included_column, is_primary_key = si.is_primary_key, is_unique = si.is_unique, has_filter = si.has_filter, filter_definition  = isnull(filter_definition,'')
					from sys.index_columns ic
					inner join sys.indexes si on si.index_id = ic.index_id and si.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i2.index_id and ic.object_id = o.object_id and si.index_id > 1
					FOR XML AUTO)
				)
			)
	) x
) y

ORDER BY TableName, IndexName1, IndexName2


/*
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[bAPPH]') AND name = N'biAPPHUniqueAttchID')
			DROP INDEX [biAPPHUniqueAttchID] ON [dbo].[bAPPH];
*/


----------------------------------------------------------------------------------------------------------------------


--Identify if fulltext catalog feature is installed
--Skip this step in Azure SQL DB
IF (SELECT FullText_Indexing_Is_Installed = fulltextserviceproperty('IsFullTextInstalled')) <> 1
BEGIN
	THROW 51000, 'Full text indexing is not installed.',0;
END;
GO

--Identify databases with a fulltext catalog present
--Skip this step in Azure SQL DB
EXEC sp_MSforeachdb 'use[?]; select Database_name = DB_Name(), fc.name from sys.fulltext_catalogs fc'
GO

SELECT	
		Fulltext_Catalog	= c.name
    ,	Table_Name	= o.name
    ,	Key_Index	= i.name
	,   Catalog_Populate_Status = FULLTEXTCATALOGPROPERTY(c.name,'PopulateStatus')
	,	Catalog_Populate_Status_Desc = 
			(SELECT CASE FULLTEXTCATALOGPROPERTY(c.name,'PopulateStatus')
						WHEN 0 THEN 'Idle' --caught up and keeping up
						WHEN 1 THEN 'Full Population In Progress' --initial status upon creation
						WHEN 2 THEN 'Paused'--PROBLEM?
						WHEN 3 THEN 'Throttled'
						WHEN 4 THEN 'Recovering'--PROBLEM
						WHEN 5 THEN 'Shutdown'--PROBLEM
						WHEN 6 THEN 'Incremental Population In Progress'
						WHEN 7 THEN 'Building Index'
						WHEN 8 THEN 'Disk Full.  Paused.' --PROBLEM
						WHEN 9 THEN 'Change Tracking' --expected when it is catching up and not up to date yet
					END) --https://docs.microsoft.com/en-us/sql/t-sql/functions/fulltextcatalogproperty-transact-sql
	,	LastCrawlStart	= fi.crawl_start_date
	,	LastCrawlEnd	= fi.crawl_end_date --null when currently crawling
	,	fi.is_enabled 
	,	c.is_default 
	,	fi.crawl_type_desc
    ,	fi.change_tracking_state_desc
	,	fi.has_crawl_completed
	,	c.is_importing -- Indicates whether the full-text catalog is being imported: 1 = The catalog is being imported. 2 = The catalog is not being imported.
	
FROM	sys.fulltext_catalogs c	
    LEFT OUTER JOIN sys.fulltext_indexes fi ON fi.fulltext_catalog_id = c.fulltext_catalog_id
	LEFT OUTER JOIN sys.objects o			ON o.[object_id] = fi.[object_id] 
    LEFT OUTER JOIN sys.indexes i			ON fi.unique_index_id = i.index_id AND fi.[object_id] = i.[object_id]
/*
WHERE  (fi.crawl_end_date is null --is currently crawling
  or fi.crawl_end_date < dateadd(day, -1, getdate())) --look for any ft index that hasn't updated recently
*/
ORDER	BY c.name, o.name, i.name, fi.crawl_start_date;

--------------------------------------------------------------------------------------------------------------------------
--index_usage_stats
--Discover indexes that aren't helping reads but still hurting writes
--Does not show tables that have never been written to

SELECT  DatabaseName		= d.name
	,	s.object_id
	,	TableName 			= ' [' + sc.name + '].[' + o.name + ']'
    ,   IndexName			= i.name
    ,   s.user_seeks
    ,   s.user_scans
    ,   s.user_lookups
    ,   s.user_updates
	,	ps.row_count
	,	SizeMb				= cast((ps.in_row_reserved_page_count*8.)/1024. as decimal(19,2))
	,	s.last_user_lookup
	,	s.last_user_scan
	,	s.last_user_seek
	,	s.last_user_update
	,	Partition_Schema_Name = psch.[name]
	,	Partition_Number = pr.partition_number
	,	[tSQL]	= '--caution! DROP INDEX [' + i.name + '] ON [' + sc.name + '].[' + o.name + ']' --caution!!
--select object_name(object_id), * 
FROM	sys.dm_db_index_usage_stats s 
        INNER JOIN sys.objects o
			 ON o.object_id=s.object_id
		inner join sys.schemas sc
			on sc.schema_id = o.schema_id
		INNER JOIN sys.indexes i
           ON i.object_id = s.object_id
              AND i.index_id = s.index_id
		left outer join sys.partitions pr 
			on pr.object_id = i.object_id 
			and pr.index_id = i.index_id
		left outer join sys.dm_db_partition_stats ps
			on ps.object_id = i.object_id
			and ps.partition_id = pr.partition_id
		left outer join sys.partition_schemes psch 
			on psch.data_space_id = i.data_space_id
		inner join sys.databases d
			on s.database_id = d.database_id
			and db_name() = d.name
WHERE 1=1 
--Strongly recommended filters
and o.is_ms_shipped = 0
and o.type_desc = 'USER_TABLE'
and i.type_desc = 'NONCLUSTERED'
and is_unique = 0
and is_primary_key = 0
and is_unique_constraint = 0

--Optional filters
--and user_updates / 50. > (user_seeks + user_scans + user_lookups ) --arbitrary
--and o.name in ('ContactBase')
--and o.name not like '%cascade%'
--and (ps.in_row_reserved_page_count) > 1280 --10mb

order by user_seeks + user_scans + user_lookups  asc,  s.user_updates desc; --most useless indexes show up first


SELECT servicename, status_desc, last_startup_time FROM sys.dm_server_services;
GO

-------------------------------------------------------------------------------------------------------------------------

---missing indexes
--Execute this version of the script for the current desired database context only.
--Look below for an all-databases version that cannot build the CREATE statement.
--Demo lab script to generate a missing index suggestion: toolbox\lab - missing index setup demo.sql

SELECT 
	mid.statement 
/* --This block SQL 2017+ only
,	create_index_statement_2017 =	'CREATE NONCLUSTERED INDEX IDX_NC_' + replace(t.name, ' ' ,'')
	+ TRANSLATE(ISNULL(replace(mid.equality_columns, ' ' ,''),'') , '],[' ,' _ ') --Translate is only supported for SQL 2017+
	+ TRANSLATE(ISNULL(replace(mid.inequality_columns, ' ' ,''),''), '],[' ,' _ ')
	+ ' ON ' + statement 
	+ ' (' + ISNULL (mid.equality_columns,'') 
    + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ', ' ELSE '' END 
    + ISNULL (mid.inequality_columns, '')
	+ ')' 
	+ ISNULL (' INCLUDE (' + mid.included_columns + ')', '')  COLLATE SQL_Latin1_General_CP1_CI_AS
	--+ ISNULL (' WITH (ONLINE = ON, SORT_IN_TEMPDB = ON)', '')  COLLATE SQL_Latin1_General_CP1_CI_AS --For SQL Server Enterprise Only
*/

,	create_index_statement	=	'CREATE NONCLUSTERED INDEX IDX_NC_' + replace(t.name, ' ' ,'')
	+ replace(replace(replace(ISNULL(replace(mid.equality_columns, ' ' ,''),'') , '],[' ,'_'),'[','_'),']','') 
	+ replace(replace(replace(ISNULL(replace(mid.inequality_columns, ' ' ,''),''), '],[' ,'_'),'[','_'),']','') 
	+ ' ON ' + statement 
	+ ' (' + ISNULL (mid.equality_columns,'') 
    + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ', ' ELSE '' END 
    + ISNULL (mid.inequality_columns, '')
	+ ')' 
	+ ISNULL (' INCLUDE (' + mid.included_columns + ')', '')  COLLATE SQL_Latin1_General_CP1_CI_AS
	--+ ISNULL (' WITH (ONLINE = ON, SORT_IN_TEMPDB = ON)', '')  COLLATE SQL_Latin1_General_CP1_CI_AS --For SQL Server Enterprise Only
,	unique_compiles, migs.user_seeks, migs.user_scans, last_user_seek, migs.avg_total_user_cost, avg_user_impact
, mid.equality_columns,  mid.inequality_columns, mid.included_columns
, quartile
--select *
FROM sys.dm_db_missing_index_groups mig
INNER JOIN 
(select *, quartile = NTILE(4) OVER (ORDER BY avg_total_user_cost asc) from sys.dm_db_missing_index_group_stats) migs 
ON migs.group_handle = mig.index_group_handle
--and migs.quartile = 1 --get only the top 25% of suggestions based on cost.
INNER JOIN sys.dm_db_missing_index_details mid 
ON mig.index_handle = mid.index_handle
inner join sys.tables t 
on t.object_id = mid.object_id
inner join sys.schemas s
on s.schema_id = t.schema_id
WHERE 1=1
and mid.database_id = db_id()
--and		(datediff(week, last_user_seek, getdate())) < 1
--and		migs.unique_compiles > 1
--and		migs.quartile >= 3
--and		migs.user_seeks > 10
--and		migs.avg_user_impact > 75
--and		t.name like '%pt_time_salesorder_ids%'
--order by avg_user_impact * avg_total_user_cost desc;
order by create_index_statement;


SELECT servicename, status_desc, last_startup_time FROM sys.dm_server_services;
GO


/*
--All databases
SELECT 
	mid.statement
,	unique_compiles, migs.user_seeks, migs.user_scans, last_user_seek, migs.avg_total_user_cost
, avg_user_impact, mid.equality_columns,  mid.inequality_columns, mid.included_columns
, quartile
--select *
FROM sys.dm_db_missing_index_groups mig
INNER JOIN 
(select *, quartile = NTILE(5) OVER (ORDER BY avg_total_user_cost asc) from sys.dm_db_missing_index_group_stats) migs 
ON migs.group_handle = mig.index_group_handle
--and migs.quartile = 1 --get only the top 20% of suggestions based on cost.
INNER JOIN sys.dm_db_missing_index_details mid 
ON mig.index_handle = mid.index_handle
WHERE 1=1
--and		(datediff(week, last_user_seek, getdate())) < 1
--and		migs.unique_compiles > 1
--and		migs.quartile >= 3
--and		migs.user_seeks > 10
--and		migs.avg_user_impact > 75
order by avg_user_impact * avg_total_user_cost desc 
*/

-----------------------------------------------------------------------------------------------------------------------


---percentage improvement index

--
-- 2007-10-11 Pedro Lopes (Microsoft) pedro.lopes@microsoft.com (http://aka.ms/sqlinsights/)
--
-- 2008-01-17 Check for possibly redundant indexes in the output.
-- 2009-05-21 Changed index scoring method; Disregards indexes with [Score] < 100000 and [User_Hits_on_Missing_Index] < 99;
-- 2013-03-21 Changed database loop method;
-- 2013-11-10 Added search for redundant indexes in missing indexes;

SET NOCOUNT ON;
SET QUOTED_IDENTIFIER ON;

DECLARE @IC VARCHAR(4000), @ICWI VARCHAR(4000), @editionCheck bit

/* Refer to http://msdn.microsoft.com/en-us/library/ms174396.aspx */	
IF (SELECT SERVERPROPERTY('EditionID')) IN (1804890536, 1872460670, 610778273, -2117995310)	
SET @editionCheck = 1 -- supports enterprise only features
ELSE	
SET @editionCheck = 0; -- does not support enterprise only features

-- Create the helper functions
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_allcols'')) DROP FUNCTION dbo.fn_createindex_allcols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_allcols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle 
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_keycols'')) DROP FUNCTION dbo.fn_createindex_keycols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_keycols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle
		AND (ic.column_usage = ''''EQUALITY'''' OR ic.column_usage = ''''INEQUALITY'''')
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_includedcols'')) DROP FUNCTION dbo.fn_createindex_includedcols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_includedcols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle
		AND ic.column_usage = ''''INCLUDE''''
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexCreation'))
DROP TABLE #IndexCreation
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexCreation'))
CREATE TABLE #IndexCreation (
	[database_id] int,
	DBName VARCHAR(255),
	[Table] VARCHAR(255),
	[ix_handle] int,
	[User_Hits_on_Missing_Index] int,
	[Estimated_Improvement_Percent] DECIMAL(5,2),
	[Avg_Total_User_Cost] int,
	[Unique_Compiles] int,
	[Score] NUMERIC(19,3),
	[KeyCols] VARCHAR(1000),
	[IncludedCols] VARCHAR(4000),
	[Ix_Name] VARCHAR(255),
	[AllCols] NVARCHAR(max),
	[KeyColsOrdered] NVARCHAR(max),
	[IncludedColsOrdered] NVARCHAR(max)
	)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexRedundant'))
DROP TABLE #IndexRedundant
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexRedundant'))
CREATE TABLE #IndexRedundant (
	DBName VARCHAR(255),
	[Table] VARCHAR(255),
	[Ix_Name] VARCHAR(255),
	[ix_handle] int,
	[KeyCols] VARCHAR(1000),
	[IncludedCols] VARCHAR(4000),
	[Redundant_With] VARCHAR(255)
	)

INSERT INTO #IndexCreation
SELECT i.database_id,
	m.[name],
	RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)) AS [Table],
	i.index_handle AS [ix_handle],
	[User_Hits_on_Missing_Index] = (s.user_seeks + s.user_scans),
	s.avg_user_impact, -- Query cost would reduce by this amount in percentage, on average.
	s.avg_total_user_cost, -- Average cost of the user queries that could be reduced by the index in the group.
	s.unique_compiles, -- Number of compilations and recompilations that would benefit from this missing index group.
	(CONVERT(NUMERIC(19,3), s.user_seeks) + CONVERT(NUMERIC(19,3), s.user_scans)) 
		* CONVERT(NUMERIC(19,3), s.avg_total_user_cost) 
		* CONVERT(NUMERIC(19,3), s.avg_user_impact) AS Score, -- The higher the score, higher is the anticipated improvement for user queries.
	CASE WHEN (i.equality_columns IS NOT NULL AND i.inequality_columns IS NULL) THEN i.equality_columns
			WHEN (i.equality_columns IS NULL AND i.inequality_columns IS NOT NULL) THEN i.inequality_columns
			ELSE i.equality_columns + ',' + i.inequality_columns END AS [KeyCols],
	i.included_columns AS [IncludedCols],
	'IX_' + LEFT(RIGHT(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), LEN(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3))) - (CHARINDEX('.', RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), 1)) - 1),
		LEN(RIGHT(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), LEN(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3))) - (CHARINDEX('.', RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), 1)) - 1)) - 1) + '_' + CAST(i.index_handle AS NVARCHAR) AS [Ix_Name],
	tempdb.dbo.fn_createindex_allcols(i.index_handle), 
	tempdb.dbo.fn_createindex_keycols(i.index_handle),
	tempdb.dbo.fn_createindex_includedcols(i.index_handle)
FROM sys.dm_db_missing_index_details i
INNER JOIN master.sys.databases m ON i.database_id = m.database_id
INNER JOIN sys.dm_db_missing_index_groups g ON i.index_handle = g.index_handle
INNER JOIN sys.dm_db_missing_index_group_stats s ON s.group_handle = g.index_group_handle
WHERE i.database_id > 4

INSERT INTO #IndexRedundant
SELECT I.DBName, I.[Table], I.[Ix_Name], i.[ix_handle], I.[KeyCols], I.[IncludedCols], I2.[Ix_Name]
FROM #IndexCreation I 
INNER JOIN #IndexCreation I2 ON I.[database_id] = I2.[database_id] AND I.[Table] = I2.[Table] AND I.[Ix_Name] <> I2.[Ix_Name]
	AND (((I.KeyColsOrdered <> I2.KeyColsOrdered OR I.[IncludedColsOrdered] <> I2.[IncludedColsOrdered])
		AND ((CASE WHEN I.[IncludedColsOrdered] IS NULL THEN I.KeyColsOrdered ELSE I.KeyColsOrdered + ',' + I.[IncludedColsOrdered] END) = (CASE WHEN I2.[IncludedColsOrdered] IS NULL THEN I2.KeyColsOrdered ELSE I2.KeyColsOrdered + ',' + I2.[IncludedColsOrdered] END)
			OR I.[AllCols] = I2.[AllCols]))
	OR (I.KeyColsOrdered <> I2.KeyColsOrdered AND I.[IncludedColsOrdered] = I2.[IncludedColsOrdered])
	OR (I.KeyColsOrdered = I2.KeyColsOrdered AND I.[IncludedColsOrdered] <> I2.[IncludedColsOrdered]))
WHERE I.[Score] >= 100000
	AND I2.[Score] >= 100000
GROUP BY I.DBName, I.[Table], I.[Ix_Name], I.[ix_handle], I.[KeyCols], I.[IncludedCols], I2.[Ix_Name]
ORDER BY I.DBName, I.[Table], I.[Ix_Name]

IF (SELECT COUNT(*) FROM #IndexCreation WHERE [Score] >= 100000) > 0
BEGIN
	SELECT 'Missing_Indexes' AS [Information], IC.DBName AS [Database_Name], IC.[Table] AS [Table_Name], CONVERT(bigint,[Score]) AS [Score], [User_Hits_on_Missing_Index], 
		[Estimated_Improvement_Percent], [Avg_Total_User_Cost], [Unique_Compiles], IC.[KeyCols], IC.[IncludedCols], IC.[Ix_Name] AS [Index_Name],
		SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
		ORDER BY IR.[Redundant_With]
	FOR XML PATH('')), 2, 8000) AS [Possibly_Redundant_With]
	FROM #IndexCreation IC
	WHERE [Score] >= 100000
	ORDER BY IC.DBName, IC.[Score] DESC, IC.[User_Hits_on_Missing_Index], IC.[Estimated_Improvement_Percent];		

	SELECT DISTINCT 'Possibly_redundant_IXs_in_list' AS Comments, I.DBName AS [Database_Name], I.[Table] AS [Table_Name], 
		I.[Ix_Name] AS [Index_Name], I.[KeyCols], I.[IncludedCols]
	FROM #IndexRedundant I
	ORDER BY I.DBName, I.[Table], I.[Ix_Name]
END
ELSE
BEGIN
	SELECT 'Missing_Indexes' AS [Information], 'None' AS [Comment]
END;

IF (SELECT COUNT(*) FROM #IndexCreation IC WHERE IC.[IncludedCols] IS NULL AND IC.[Score] >= 100000) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */' + CHAR(10)
	PRINT '--############# Indexes creation statements #############' + CHAR(10)
	DECLARE cIC CURSOR FAST_FORWARD FOR
	SELECT '-- User Hits on Missing Index ' + IC.[Ix_Name] + ': ' + CONVERT(VARCHAR(20),IC.[User_Hits_on_Missing_Index]) + CHAR(10) +
		'-- Estimated Improvement Percent: ' + CONVERT(VARCHAR(6),IC.[Estimated_Improvement_Percent]) + CHAR(10) +
		'-- Average Total User Cost: ' + CONVERT(VARCHAR(50),IC.[Avg_Total_User_Cost]) + CHAR(10) +
		'-- Unique Compiles: ' + CONVERT(VARCHAR(50),IC.[Unique_Compiles]) + CHAR(10) +
		'-- Score: ' + CONVERT(VARCHAR(20),CONVERT(bigint,IC.[Score])) + 
		CASE WHEN (SELECT COUNT(IR.[Redundant_With]) FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]) > 0 
		THEN CHAR(10) + '-- Possibly Redundant with Missing Index(es): ' + SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
			FOR XML PATH('')), 2, 8000) 
		ELSE '' END +
		CHAR(10) + 'USE ' + QUOTENAME(IC.DBName) + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sysindexes WHERE name = N''' +
		IC.[Ix_Name] + ''') DROP INDEX ' + IC.[Table] + '.' +
		IC.[Ix_Name] + ';' + CHAR(10) + 'GO' + CHAR(10) + 'CREATE INDEX ' +
		IC.[Ix_Name] + ' ON ' + IC.[Table] + ' (' + IC.[KeyCols] + CASE WHEN @editionCheck = 1 THEN ') WITH (ONLINE = ON);' ELSE ');' END + CHAR(10) + 'GO' + CHAR(10)
	FROM #IndexCreation IC
	WHERE IC.[IncludedCols] IS NULL AND IC.[Score] >= 100000
	ORDER BY IC.DBName, IC.[Table], IC.[Ix_Name]
	OPEN cIC
	FETCH NEXT FROM cIC INTO @IC
	WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @IC
			FETCH NEXT FROM cIC INTO @IC
		END
	CLOSE cIC
	DEALLOCATE cIC
END;

IF (SELECT COUNT(*) FROM #IndexCreation IC WHERE IC.[IncludedCols] IS NOT NULL AND IC.[Score] >= 100000) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */' + CHAR(10)
	PRINT '--############# Covering indexes creation statements #############' + CHAR(10)
	DECLARE cICWI CURSOR FAST_FORWARD FOR
	SELECT '-- User Hits on Missing Index ' + IC.[Ix_Name] + ': ' + CONVERT(VARCHAR(20),IC.[User_Hits_on_Missing_Index]) + CHAR(10) +
		'-- Estimated Improvement Percent: ' + CONVERT(VARCHAR(6),IC.[Estimated_Improvement_Percent]) + CHAR(10) +
		'-- Average Total User Cost: ' + CONVERT(VARCHAR(50),IC.[Avg_Total_User_Cost]) + CHAR(10) +
		'-- Unique Compiles: ' + CONVERT(VARCHAR(50),IC.[Unique_Compiles]) + CHAR(10) +
		'-- Score: ' + CONVERT(VARCHAR(20),CONVERT(bigint,IC.[Score])) + 
		CASE WHEN (SELECT COUNT(IR.[Redundant_With]) FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]) > 0 
		THEN CHAR(10) + '-- Possibly Redundant with Missing Index(es): ' + SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
			FOR XML PATH('')), 2, 8000) 
		ELSE '' END + 
		CHAR(10) + 'USE ' + QUOTENAME(IC.DBName) + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sysindexes WHERE name = N''' +
		IC.[Ix_Name] + ''') DROP INDEX ' + IC.[Table] + '.' +
		IC.[Ix_Name] + ';' + CHAR(10) + 'GO' + CHAR(10) + 'CREATE INDEX ' +
		IC.[Ix_Name] + ' ON ' + IC.[Table] + ' (' + IC.[KeyCols] + CASE WHEN @editionCheck = 1 THEN ') WITH (ONLINE = ON);' ELSE ');' END + CHAR(10) + 'GO' + CHAR(10)
	FROM #IndexCreation IC
	WHERE IC.[IncludedCols] IS NOT NULL AND IC.[Score] >= 100000
	ORDER BY IC.DBName, IC.[Table], IC.[Ix_Name]
	OPEN cICWI
	FETCH NEXT FROM cICWI INTO @ICWI
	WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @ICWI
			FETCH NEXT FROM cICWI INTO @ICWI
		END
	CLOSE cICWI
	DEALLOCATE cICWI
END;

DROP TABLE #IndexCreation
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_keycols'')) DROP FUNCTION dbo.fn_createindex_keycols')
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_allcols'')) DROP FUNCTION dbo.fn_createindex_allcols')
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_includedcols'')) DROP FUNCTION dbo.fn_createindex_includedcols')
GO


---view_HypObjects.sql

--
-- 2012-06-14 Pedro Lopes (Microsoft) pedro.lopes@microsoft.com (http://aka.ms/sqlinsights/)
--
-- List Hypothetical objects (with drop statements);
--

SET NOCOUNT ON;

DECLARE @i int, @maxi int, @dbname sysname, @sqlcmd NVARCHAR(4000), @dbid int, @ErrorMessage NVARCHAR(500)

IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpdbs'))
CREATE TABLE #tmpdbs (id int IDENTITY(1,1), [dbid] int, [dbname] sysname)

INSERT INTO #tmpdbs ([dbid], [dbname])
SELECT database_id, name FROM master.sys.databases WHERE is_read_only = 0 AND state = 0 AND database_id > 4 AND is_distributor = 0;

IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblHypObj'))
CREATE TABLE #tblHypObj ([DBName] sysname, [Table] VARCHAR(255), [Object] VARCHAR(255), [Type] VARCHAR(10))

SET @i = 1
SET @maxi = (SELECT MAX(id) FROM #tmpdbs)

WHILE @i <= @maxi
BEGIN
	SET @dbname = (SELECT [dbname] FROM #tmpdbs WHERE id = @i)
	SET @dbid = (SELECT [dbid] FROM #tmpdbs WHERE id = @i)
	SET @sqlcmd = 'SELECT ''' + @dbname + ''' AS [DBName], QUOTENAME(o.[name]), i.name, ''INDEX'' FROM ' + QUOTENAME(@dbname) + '.sys.indexes i 
INNER JOIN sys.objects o ON o.[object_id] = i.[object_id] 
INNER JOIN sys.tables AS mst ON mst.[object_id] = i.[object_id]
INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
WHERE i.is_hypothetical = 1
UNION ALL
SELECT ''' + @dbname + ''' AS [DBName], QUOTENAME(o.[name]), s.name, ''STATISTICS'' FROM ' + QUOTENAME(@dbname) + '.sys.stats s 
INNER JOIN sys.objects o (NOLOCK) ON o.[object_id] = s.[object_id]
INNER JOIN sys.tables AS mst (NOLOCK) ON mst.[object_id] = s.[object_id]
INNER JOIN sys.schemas AS t (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE (s.name LIKE ''hind_%'' OR s.name LIKE ''_dta_stat%'') AND auto_created = 0
AND s.name NOT IN (SELECT name FROM ' + QUOTENAME(@dbname) + '.sys.indexes)'

	BEGIN TRY
		INSERT INTO #tblHypObj
		EXECUTE sp_executesql @sqlcmd
	END TRY
	BEGIN CATCH
		SELECT ERROR_NUMBER() AS ErrorNumber, ERROR_MESSAGE() AS ErrorMessage;
		SELECT @ErrorMessage = 'Hypothetical objects subsection - Error raised in TRY block. ' + ERROR_MESSAGE()
		RAISERROR (@ErrorMessage,16,1);
	END CATCH
	
	SET @i = @i + 1
END	

IF (SELECT COUNT([Object]) FROM #tblHypObj) > 0
BEGIN
	SELECT 'Hypothetical_objects' AS [Information], '[WARNING: Some databases have indexes or statistics that are marked as hypothetical. It is recommended to drop these objects as soon as possible]' AS [Deviation]
	SELECT 'Hypothetical_objects' AS [Information], DBName AS [Database Name], [Table] AS [Table Name], [Object] AS [Object Name], [Type] AS [Object Type]
	FROM #tblHypObj
	ORDER BY 2, 3, 5
	
	DECLARE @strSQL NVARCHAR(4000)
	PRINT '--** Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */' + CHAR(10)

	PRINT CHAR(10) + '--############# Existing Hypothetical objects drop statements #############' + CHAR(10)
	
	DECLARE ITW_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + [DBName] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM ' + CASE WHEN [Type] = 'STATISTICS' THEN 'sys.stats' ELSE 'sys.indexes' END + ' WHERE name = N'''+ [Object] + ''')' + CHAR(10) +
	CASE WHEN [Type] = 'STATISTICS' THEN 'DROP STATISTICS ' + [Table] + '.' +  QUOTENAME([Object]) + ';' + CHAR(10) + 'GO' + CHAR(10)
		ELSE 'DROP INDEX ' + QUOTENAME([Object]) + ' ON ' + [Table] + ';' + CHAR(10) + 'GO' + CHAR(10) 
		END
	FROM #tblHypObj
	ORDER BY DBName, [Table]

	OPEN ITW_Stats
	FETCH NEXT FROM ITW_Stats INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM ITW_Stats INTO @strSQL
	END
	CLOSE ITW_Stats
	DEALLOCATE ITW_Stats

	PRINT '--############# Ended Hypothetical objects drop statements #############' + CHAR(10)

END
ELSE
BEGIN
	SELECT 'Hypothetical_objects' AS [Information], '[OK]' AS [Deviation]
END;

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpdbs'))
DROP TABLE #tmpdbs;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblHypObj'))
DROP TABLE #tblHypObj;
GO

----view_IndexInformation.sql

-- 2012-03-19 Pedro Lopes (Microsoft) pedro.lopes@microsoft.com (http://aka.ms/ezequiel)
--
-- All Databases index info, including duplicate, redundant, rarely used and unused indexes.
--
-- 4/5/2012		Simplified execution by subdividing input queries
-- 4/5/2012		Fixed some collation issues;
-- 4/6/2012		Split in separate listings the unused indexes from rarely used indexes; Split in separate list
-- 6/6/2012		Fixed issue with partition aligned indexes
-- 10/31/2012	Widened search for Redundant Indexes
-- 12/17/2012	Fixed several issues
-- 1/17/2013	Added several index related info
-- 2/1/2013		Fixed issue with Heap identification
-- 2/26/2013	Fixed issue with partition info; Removed alternate keys from search for Unused and Rarely used
-- 4/17/2013	Added more information to duplicate and redundant indexes output, valuable when deciding which
-- 4/19/2013	Fixed issue with potential duplicate index_ids in sys.dm_db_index_operational_stats relating t
-- 5/6/2013		Changed data collection to minimize blocking potential on VLDBs.
-- 5/20/2013	Fixed issue with database names with special characters.
-- 5/29/2013	Fixed issue with large integers in aggregation.
-- 6/20/2013	Added step to avoid entering in loop that generates dump in SQL 2005.
-- 11/10/2013	Added index checks.
-- 2/24/2014	Added info to Unused_IX section.
-- 6/4/2014		Refined search for duplicate and redundant indexes.
-- 11/12/2014	Added SQL 2014 Hash indexes support; changed scan mode to LIMITED; added search for hard coded
-- 11/2/2016	Added support for SQL Server 2016 sys.dm_db_index_operational_stats changes; Added script creation.

/*
NOTE: on SQL Server 2005, be aware that querying sys.dm_db_index_usage_stats when it has large number of rows may lead to performance issues.
URL: http://support.microsoft.com/kb/2003031
*/

SET NOCOUNT ON;

DECLARE @UpTime VARCHAR(12), @StartDate DATETIME, @sqlmajorver int, @sqlcmd NVARCHAR(4000), @params NVARCHAR(500)
DECLARE @DatabaseName sysname, @indexName sysname
SELECT @sqlmajorver = CONVERT(int, (@@microsoftversion / 0x1000000) & 0xff);

IF @sqlmajorver = 9
BEGIN
	SET @sqlcmd = N'SELECT @StartDateOUT = login_time, @UpTimeOUT = DATEDIFF(mi, login_time, GETDATE()) FROM master..sysprocesses WHERE spid = 1';
END
ELSE
BEGIN
	SET @sqlcmd = N'SELECT @StartDateOUT = sqlserver_start_time, @UpTimeOUT = DATEDIFF(mi,sqlserver_start_time,GETDATE()) FROM sys.dm_os_sys_info';
END

SET @params = N'@StartDateOUT DATETIME OUTPUT, @UpTimeOUT VARCHAR(12) OUTPUT';

EXECUTE sp_executesql @sqlcmd, @params, @StartDateOUT=@StartDate OUTPUT, @UpTimeOUT=@UpTime OUTPUT;

SELECT @StartDate AS Collecting_Data_Since, CONVERT(VARCHAR(4),@UpTime/60/24) + 'd ' + CONVERT(VARCHAR(4),@UpTime/60%24) + 'h ' + CONVERT(VARCHAR(4),@UpTime%60) + 'm' AS Collecting_Data_For

RAISERROR (N'Starting...', 10, 1) WITH NOWAIT

DECLARE @dbid int--, @sqlcmd NVARCHAR(4000)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblDatabases'))
DROP TABLE #tblDatabases;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblDatabases'))
CREATE TABLE #tblDatabases (database_id int PRIMARY KEY, is_done bit)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
DROP TABLE #tblWorking;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
CREATE TABLE #tblWorking (database_id int, [object_id] int, [object_name] NVARCHAR(255), index_id int, index_name NVARCHAR(255), [schema_name] NVARCHAR(255), partition_number int, is_done bit)

INSERT INTO #tblDatabases 
SELECT database_id, 0 FROM sys.databases WHERE is_read_only = 0 AND state = 0 AND database_id > 4 AND is_distributor = 0;

RAISERROR (N'Populating support tables...', 10, 1) WITH NOWAIT

WHILE (SELECT COUNT(*) FROM #tblDatabases WHERE is_done = 0) > 0
BEGIN
	SELECT TOP 1 @dbid = database_id FROM #tblDatabases WHERE is_done = 0
SELECT @sqlcmd = 'SELECT ' + CONVERT(NVARCHAR(255), @dbid) + ', si.[object_id], mst.[name], si.index_id, si.name, t.name, sp.partition_number, 0
FROM [' + DB_NAME(@dbid) + '].sys.indexes si
INNER JOIN [' + DB_NAME(@dbid) + '].sys.partitions sp ON si.[object_id] = sp.[object_id] AND si.index_id = sp.index_id
INNER JOIN [' + DB_NAME(@dbid) + '].sys.tables AS mst ON mst.[object_id] = si.[object_id]
INNER JOIN [' + DB_NAME(@dbid) + '].sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
WHERE mst.is_ms_shipped = 0'
	INSERT INTO #tblWorking
	EXEC sp_executesql @sqlcmd;
	
	UPDATE #tblDatabases
	SET is_done = 1
	WHERE database_id = @dbid;
END

--------------------------------------------------------
-- Index physical and usage stats
--------------------------------------------------------
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
DROP TABLE #tmpIPS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
CREATE TABLE #tmpIPS (
	[database_id] int,
	[object_id] int,
	[index_id] int,
	[partition_number] int,
	fragmentation DECIMAL(18,3),
	[page_count] bigint,
	[size_MB] DECIMAL(26,3),
	record_count int,
	forwarded_record_count int NULL,
	CONSTRAINT PK_IPS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]))

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
DROP TABLE #tmpIOS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
CREATE TABLE #tmpIOS (
	[database_id] int,
	[object_id] int,
	[index_id] int,
	[partition_number] int,
	range_scan_count bigint NULL,
	singleton_lookup_count bigint NULL,
	forwarded_fetch_count bigint NULL,
	row_lock_count bigint NULL,
	row_lock_wait_count bigint NULL,
	row_lock_pct NUMERIC(15,2) NULL,
	row_lock_wait_in_ms bigint NULL,
	[avg_row_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_lock_count bigint NULL,
	page_lock_wait_count bigint NULL,
	page_lock_pct NUMERIC(15,2) NULL,
	page_lock_wait_in_ms bigint NULL,
	[avg_page_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_io_latch_wait_in_ms bigint NULL,
	[avg_page_io_latch_wait_in_ms] NUMERIC(15,2) NULL
	CONSTRAINT PK_IOS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
DROP TABLE #tmpIUS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
CREATE TABLE #tmpIUS (
	[database_id] int,
	[schema_name] VARCHAR(100) COLLATE database_default,
	[object_id] int,
	[index_id] int,
	[Hits] bigint NULL,
	[Reads_Ratio] DECIMAL(5,2),
	[Writes_Ratio] DECIMAL(5,2),
	user_updates bigint,
	last_user_seek DATETIME NULL,
	last_user_scan DATETIME NULL,
	last_user_lookup DATETIME NULL,
	last_user_update DATETIME NULL
	CONSTRAINT PK_IUS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
DROP TABLE #tmpIxs;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
CREATE TABLE #tmpIxs (
	[database_id] int, 
	[database_name] VARCHAR(500), 
	[object_id] int, 
	[schema_name] VARCHAR(100) COLLATE database_default, 
	[table_name] VARCHAR(300) COLLATE database_default, 
	[index_id] int, 
	[index_name] VARCHAR(300) COLLATE database_default,
	[partition_number] int,
	[index_type] tinyint,
	type_desc NVARCHAR(30),
	is_primary_key bit,
	is_unique_constraint bit,
	is_disabled bit,
	fill_factor tinyint, 
	is_unique bit, 
	is_padded bit, 
	has_filter bit,
	filter_definition NVARCHAR(max),
	KeyCols VARCHAR(4000), 
	KeyColsOrdered VARCHAR(4000), 
	IncludedCols VARCHAR(4000) NULL, 
	IncludedColsOrdered VARCHAR(4000) NULL, 
	AllColsOrdered VARCHAR(4000) NULL,
	[KeyCols_data_length_bytes] int,
	CONSTRAINT PK_Ixs PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
DROP TABLE #tmpAgg;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
CREATE TABLE #tmpAgg (
	[database_id] int,
	[database_name] sysname,
	[object_id] int,
	[schema_name] VARCHAR(100) COLLATE database_default,
	[table_name] VARCHAR(300) COLLATE database_default,
	[index_id] int,
	[index_name] VARCHAR(300) COLLATE database_default,
	[partition_number] int,
	fragmentation DECIMAL(18,3),
	fill_factor tinyint,
	[page_count] bigint,
	[size_MB] DECIMAL(26,3),
	record_count bigint, 
	forwarded_record_count bigint NULL,
	range_scan_count bigint NULL,
	singleton_lookup_count bigint NULL,
	forwarded_fetch_count bigint NULL,
	row_lock_count bigint NULL,
	row_lock_wait_count bigint NULL,
	row_lock_pct NUMERIC(15,2) NULL,
	row_lock_wait_in_ms bigint NULL,
	[avg_row_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_lock_count bigint NULL,
	page_lock_wait_count bigint NULL,
	page_lock_pct NUMERIC(15,2) NULL,
	page_lock_wait_in_ms bigint NULL,
	[avg_page_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_io_latch_wait_in_ms bigint NULL,
	[avg_page_io_latch_wait_in_ms] NUMERIC(15,2) NULL,
	[Hits] bigint NULL,
	[Reads_Ratio] DECIMAL(5,2),
	[Writes_Ratio] DECIMAL(5,2),
	user_updates bigint,
	last_user_seek DATETIME NULL,
	last_user_scan DATETIME NULL,
	last_user_lookup DATETIME NULL,
	last_user_update DATETIME NULL,
	KeyCols VARCHAR(4000) COLLATE database_default,
	KeyColsOrdered VARCHAR(4000) COLLATE database_default,
	IncludedCols VARCHAR(4000) COLLATE database_default NULL,
	IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
	AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
	is_unique bit,
	[type] tinyint,
	type_desc NVARCHAR(30),
	is_primary_key bit,
	is_unique_constraint bit,
	is_padded bit, 
	has_filter bit, 
	filter_definition NVARCHAR(max),
	is_disabled bit,
	[KeyCols_data_length_bytes] int,	
	CONSTRAINT PK_tmpAgg PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
DROP TABLE #tblCode;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
CREATE TABLE #tblCode (
	[DatabaseName] sysname, 
	[schemaName] VARCHAR(100), 
	[objectName] VARCHAR(200), 
	[indexName] VARCHAR(200), 
	type_desc NVARCHAR(60));
	
IF @sqlmajorver >= 12
BEGIN
	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
	DROP TABLE #tmpXIS;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
	CREATE TABLE #tmpXIS (
		[database_id] int,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		total_bucket_count bigint, 
		empty_bucket_count bigint, 
		avg_chain_length bigint, 
		max_chain_length bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		CONSTRAINT PK_tmpXIS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
	DROP TABLE #tmpXNCIS;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
	CREATE TABLE #tmpXNCIS (
		[database_id] int,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		delta_pages bigint, 
		internal_pages bigint, 
		leaf_pages bigint, 
		page_update_count bigint,
		page_update_retry_count bigint, 
		page_consolidation_count bigint,
		page_consolidation_retry_count bigint, 
		page_split_count bigint, 
		page_split_retry_count bigint,
		key_split_count bigint, 
		key_split_retry_count bigint, 
		page_merge_count bigint, 
		page_merge_retry_count bigint,
		key_merge_count bigint, 
		key_merge_retry_count bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		CONSTRAINT PK_tmpXNCIS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
	DROP TABLE #tmpAggXTPHash;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
	CREATE TABLE #tmpAggXTPHash (
		[database_id] int,
		[database_name] sysname,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		total_bucket_count bigint, 
		empty_bucket_count bigint, 
		avg_chain_length bigint, 
		max_chain_length bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		KeyCols VARCHAR(4000) COLLATE database_default,
		KeyColsOrdered VARCHAR(4000) COLLATE database_default,
		IncludedCols VARCHAR(4000) COLLATE database_default NULL,
		IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
		AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
		is_unique bit,
		[type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_padded bit, 
		has_filter bit, 
		filter_definition NVARCHAR(max),
		is_disabled bit,
		[KeyCols_data_length_bytes] int,	
		CONSTRAINT PK_tmpAggXTPHash PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
	DROP TABLE #tmpAggXTPNC;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
	CREATE TABLE #tmpAggXTPNC (
		[database_id] int,
		[database_name] sysname,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		delta_pages bigint, 
		internal_pages bigint, 
		leaf_pages bigint, 
		page_update_count bigint,
		page_update_retry_count bigint, 
		page_consolidation_count bigint,
		page_consolidation_retry_count bigint, 
		page_split_count bigint, 
		page_split_retry_count bigint,
		key_split_count bigint, 
		key_split_retry_count bigint, 
		page_merge_count bigint, 
		page_merge_retry_count bigint,
		key_merge_count bigint, 
		key_merge_retry_count bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		KeyCols VARCHAR(4000) COLLATE database_default,
		KeyColsOrdered VARCHAR(4000) COLLATE database_default,
		IncludedCols VARCHAR(4000) COLLATE database_default NULL,
		IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
		AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
		is_unique bit,
		[type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_padded bit,
		has_filter bit,
		filter_definition NVARCHAR(max),
		is_disabled bit,
		[KeyCols_data_length_bytes] int,	
		CONSTRAINT PK_tmpAggXTPNC PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
	DROP TABLE #tmpHashIxs;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
	CREATE TABLE #tmpHashIxs (
		[database_id] int, 
		[database_name] VARCHAR(500), 
		[object_id] int, 
		[schema_name] VARCHAR(100) COLLATE database_default, 
		[table_name] VARCHAR(300) COLLATE database_default, 
		[index_id] int, 
		[index_name] VARCHAR(300) COLLATE database_default,
		[partition_number] int,
		[index_type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_disabled bit,
		fill_factor tinyint, 
		is_unique bit, 
		is_padded bit, 
		has_filter bit,
		filter_definition NVARCHAR(max),
		[bucket_count] bigint,
		KeyCols VARCHAR(4000), 
		KeyColsOrdered VARCHAR(4000), 
		IncludedCols VARCHAR(4000) NULL, 
		IncludedColsOrdered VARCHAR(4000) NULL, 
		AllColsOrdered VARCHAR(4000) NULL,
		[KeyCols_data_length_bytes] int,
		CONSTRAINT PK_HashIxs PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));
END;

DECLARE /*@dbid int, */@objectid int, @indexid int, @partition_nr int, @dbname NVARCHAR(255), @oname NVARCHAR(255), @iname NVARCHAR(255), @sname NVARCHAR(255)

RAISERROR (N'Gathering sys.dm_db_index_physical_stats and sys.dm_db_index_operational_stats data...', 10, 1) WITH NOWAIT

WHILE (SELECT COUNT(*) FROM #tblWorking WHERE is_done = 0) > 0
BEGIN
	SELECT TOP 1 @dbid = database_id, @objectid = [object_id], @indexid = index_id, @partition_nr = partition_number, @oname = [object_name], @iname = index_name, @sname = [schema_name]
	FROM #tblWorking WHERE is_done = 0
	
	INSERT INTO #tmpIPS
	SELECT ps.database_id, 
		ps.[object_id], 
		ps.index_id, 
		ps.partition_number, 
		SUM(ps.avg_fragmentation_in_percent),
		SUM(ps.page_count),
		CAST((SUM(ps.page_count)*8)/1024 AS DECIMAL(26,3)) AS [size_MB],
		SUM(ISNULL(ps.record_count,0)),
		SUM(ISNULL(ps.forwarded_record_count,0)) -- for heaps
	FROM sys.dm_db_index_physical_stats(@dbid, @objectid, @indexid , @partition_nr, 'SAMPLED') AS ps
	WHERE /*ps.index_id > 0 -- ignore heaps
		AND */ps.index_level = 0 -- leaf-level nodes only
		AND ps.alloc_unit_type_desc = 'IN_ROW_DATA'
	GROUP BY ps.database_id, ps.[object_id], ps.index_id, ps.partition_number
	OPTION (MAXDOP 2);

	-- Avoid entering in loop that generates dump in SQL 2005
	IF @sqlmajorver = 9
	BEGIN
		SET @sqlcmd = (SELECT 'USE [' + DB_NAME(@dbid) + '];
UPDATE STATISTICS ' + QUOTENAME(@sname) + '.' + QUOTENAME(@oname) + CASE WHEN @iname IS NULL THEN '' ELSE ' (' + QUOTENAME(@iname) + ')' END)
		EXEC sp_executesql @sqlcmd
	END;
	SET @sqlcmd = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + DB_NAME(@dbid) + '];
WITH osCTE (database_id, [object_id], index_id, partition_number, range_scan_count, singleton_lookup_count, 
	forwarded_fetch_count, row_lock_count, row_lock_wait_count, row_lock_wait_in_ms, page_lock_count, 
	page_lock_wait_count, page_lock_wait_in_ms, page_io_latch_wait_count, page_io_latch_wait_in_ms)
AS (SELECT os.database_id, 
	os.[object_id], 
	os.index_id,
	os.partition_number, 
	SUM(os.range_scan_count), 
	SUM(os.singleton_lookup_count),
	SUM(os.forwarded_fetch_count),
	SUM(os.row_lock_count),
	SUM(os.row_lock_wait_count),
	SUM(os.row_lock_wait_in_ms),
	SUM(os.page_lock_count),
	SUM(os.page_lock_wait_count),
	SUM(os.page_lock_wait_in_ms),
	SUM(os.page_io_latch_wait_count),
	SUM(os.page_io_latch_wait_in_ms)
FROM sys.dm_db_index_operational_stats(' + CONVERT(NVARCHAR(20), @dbid) + ', ' + CONVERT(NVARCHAR(20), @objectid) + ', ' + CONVERT(NVARCHAR(20), @indexid) + ', ' + CONVERT(NVARCHAR(20), @partition_nr) + ') AS os
INNER JOIN sys.objects AS o WITH (NOLOCK) ON os.[object_id] = o.[object_id]
' + CASE WHEN @sqlmajorver >= 13 THEN 'LEFT JOIN sys.internal_partitions AS ip WITH (NOLOCK) ON os.hobt_id = ip.hobt_id AND ip.internal_object_type IN (2,3)' ELSE '' END + '
WHERE o.[type] = ''U''
GROUP BY os.database_id, os.[object_id], os.index_id, os.partition_number
)
SELECT osCTE.database_id, 
	osCTE.[object_id], 
	osCTE.index_id,
	osCTE.partition_number, 
	osCTE.range_scan_count, 
	osCTE.singleton_lookup_count,
	osCTE.forwarded_fetch_count,
	osCTE.row_lock_count,
	osCTE.row_lock_wait_count,
	CAST(100.0 * osCTE.row_lock_wait_count / (1 + osCTE.row_lock_count) AS numeric(15,2)) AS row_lock_pct,
	osCTE.row_lock_wait_in_ms,
	CAST(1.0 * osCTE.row_lock_wait_in_ms / (1 + osCTE.row_lock_wait_count) AS numeric(15,2)) AS [avg_row_lock_waits_in_ms],
	osCTE.page_lock_count,
	osCTE.page_lock_wait_count,
	CAST(100.0 * osCTE.page_lock_wait_count / (1 + osCTE.page_lock_count) AS numeric(15,2)) AS page_lock_pct,
	osCTE.page_lock_wait_in_ms,
	CAST(1.0 * osCTE.page_lock_wait_in_ms / (1 + osCTE.page_lock_wait_count) AS numeric(15,2)) AS [avg_page_lock_waits_in_ms],
	osCTE.page_io_latch_wait_in_ms,
	CAST(1.0 * osCTE.page_io_latch_wait_in_ms / (1 + osCTE.page_io_latch_wait_count) AS numeric(15,2)) AS [avg_page_io_latch_wait_in_ms]
FROM osCTE
--WHERE os.index_id > 0 -- ignore heaps
OPTION (MAXDOP 2);'

	INSERT INTO #tmpIOS
	EXEC sp_executesql @sqlcmd

	UPDATE #tblWorking
	SET is_done = 1
	WHERE database_id = @dbid AND [object_id] = @objectid AND index_id = @indexid AND partition_number = @partition_nr
END;

RAISERROR (N'Gathering sys.dm_db_index_usage_stats data...', 10, 1) WITH NOWAIT

UPDATE #tblDatabases
SET is_done = 0;

WHILE (SELECT COUNT(*) FROM #tblDatabases WHERE is_done = 0) > 0
BEGIN
	SELECT TOP 1 @dbid = database_id FROM #tblDatabases WHERE is_done = 0
	SELECT @dbname = DB_NAME(@dbid)
	
	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT s.database_id, t.name, s.[object_id], s.index_id,
	(s.user_seeks + s.user_scans + s.user_lookups) AS [Hits],
	RTRIM(CONVERT(NVARCHAR(20),CAST(CASE WHEN (s.user_seeks + s.user_scans + s.user_lookups) = 0 THEN 0 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups)) * 100 /
		CASE (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates) WHEN 0 THEN 1 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates)) END END AS DECIMAL(18,2))) COLLATE database_default) AS [Reads_Ratio],
	RTRIM(CONVERT(NVARCHAR(20),CAST(CASE WHEN s.user_updates = 0 THEN 0 ELSE CONVERT(REAL, s.user_updates) * 100 /
		CASE (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates) WHEN 0 THEN 1 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates)) END END AS DECIMAL(18,2))) COLLATE database_default) AS [Writes_Ratio],
	s.user_updates,
	MAX(s.last_user_seek) AS last_user_seek,
	MAX(s.last_user_scan) AS last_user_scan,
	MAX(s.last_user_lookup) AS last_user_lookup,
	MAX(s.last_user_update) AS last_user_update
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.objects AS o WITH (NOLOCK) ON s.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = s.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U''
	AND s.database_id = ' + CONVERT(NVARCHAR(20), @dbid) + ' 
	--AND s.index_id > 0 -- ignore heaps
GROUP BY s.database_id, t.name, s.[object_id], s.index_id, s.user_seeks, s.user_scans, s.user_lookups, s.user_updates
OPTION (MAXDOP 2)'

	INSERT INTO #tmpIUS
	EXECUTE sp_executesql @sqlcmd

	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], t.name, i.[object_id], i.index_id, 0, 0, 0, NULL, NULL, NULL, NULL, NULL
FROM sys.indexes i WITH (NOLOCK)
INNER JOIN sys.objects o WITH (NOLOCK) ON i.object_id = o.object_id 
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = i.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U''
AND i.index_id NOT IN (SELECT s.index_id
	FROM sys.dm_db_index_usage_stats s WITH (NOLOCK)
	WHERE s.object_id = i.object_id 
		AND i.index_id = s.index_id 
		AND database_id = ' + CONVERT(NVARCHAR(20), @dbid) + ')
		AND i.name IS NOT NULL
		AND i.index_id > 1'

	INSERT INTO #tmpIUS
	EXECUTE sp_executesql @sqlcmd

	UPDATE #tblDatabases
	SET is_done = 1
	WHERE database_id = @dbid;
END;

IF @sqlmajorver >= 12
BEGIN
	RAISERROR (N'Gathering sys.dm_db_xtp_hash_index_stats and sys.dm_db_xtp_nonclustered_index_stats data...', 10, 1) WITH NOWAIT

	UPDATE #tblDatabases
	SET is_done = 0;

	WHILE (SELECT COUNT(*) FROM #tblDatabases WHERE is_done = 0) > 0
	BEGIN
		SELECT TOP 1 @dbid = database_id FROM #tblDatabases WHERE is_done = 0
		SELECT @dbname = DB_NAME(@dbid)
		
		SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], xis.[object_id], t.name, o.name, xis.index_id, si.name, 
	xhis.total_bucket_count, xhis.empty_bucket_count, xhis.avg_chain_length, xhis.max_chain_length, 
	xis.scans_started, xis.scans_retries, xis.rows_returned, xis.rows_touched
FROM sys.dm_db_xtp_hash_index_stats xhis
INNER JOIN sys.dm_db_xtp_index_stats xis ON xis.[object_id] = xhis.[object_id] AND xis.[index_id] = xhis.[index_id] 
INNER JOIN sys.indexes AS si WITH (NOLOCK) ON xis.[object_id] = si.[object_id] AND xis.[index_id] = si.[index_id]
INNER JOIN sys.objects AS o WITH (NOLOCK) ON si.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = o.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U'''

		INSERT INTO #tmpXIS
		EXECUTE sp_executesql @sqlcmd
	
		SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id],
	xis.[object_id], t.name, o.name, xis.index_id, si.name, 
	xnis.delta_pages, xnis.internal_pages, xnis.leaf_pages, xnis.page_update_count,
	xnis.page_update_retry_count, xnis.page_consolidation_count,
	xnis.page_consolidation_retry_count, xnis.page_split_count, xnis.page_split_retry_count,
	xnis.key_split_count, xnis.key_split_retry_count, xnis.page_merge_count, xnis.page_merge_retry_count,
	xnis.key_merge_count, xnis.key_merge_retry_count,
	xis.scans_started, xis.scans_retries, xis.rows_returned, xis.rows_touched
FROM sys.dm_db_xtp_nonclustered_index_stats AS xnis WITH (NOLOCK)
INNER JOIN sys.dm_db_xtp_index_stats AS xis WITH (NOLOCK) ON xis.[object_id] = xnis.[object_id] AND xis.[index_id] = xnis.[index_id]
INNER JOIN sys.indexes AS si WITH (NOLOCK) ON xis.[object_id] = si.[object_id] AND xis.[index_id] = si.[index_id]
INNER JOIN sys.objects AS o WITH (NOLOCK) ON si.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = o.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U'''
	
		INSERT INTO #tmpXNCIS
		EXECUTE sp_executesql @sqlcmd

		UPDATE #tblDatabases
		SET is_done = 1
		WHERE database_id = @dbid;
	END
END;

RAISERROR (N'Gathering index column data...', 10, 1) WITH NOWAIT

UPDATE #tblDatabases
SET is_done = 0;

WHILE (SELECT COUNT(*) FROM #tblDatabases WHERE is_done = 0) > 0
BEGIN
	SELECT TOP 1 @dbid = database_id FROM #tblDatabases WHERE is_done = 0
	SELECT @dbname = DB_NAME(@dbid)

	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], ''' + DB_NAME(@dbid) + ''' AS database_name,
	mst.[object_id], t.name, mst.[name], 
	mi.index_id, mi.[name], p.partition_number,
	mi.[type], mi.[type_desc], mi.is_primary_key, mi.is_unique_constraint, mi.is_disabled, 
	mi.fill_factor, mi.is_unique, mi.is_padded, ' + CASE WHEN @sqlmajorver > 9 THEN 'mi.has_filter, mi.filter_definition,' ELSE 'NULL, NULL,' END + '
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS KeyCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS KeyColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS IncludedCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS IncludedColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS AllColsOrdered,
	(SELECT SUM(CASE sty.name WHEN ''nvarchar'' THEN sc.max_length/2 ELSE sc.max_length END) FROM sys.indexes AS i
		INNER JOIN sys.tables AS t ON t.[object_id] = i.[object_id]
		INNER JOIN sys.schemas ss ON ss.[schema_id] = t.[schema_id]
		INNER JOIN sys.index_columns AS sic ON sic.object_id = mst.object_id AND sic.index_id = mi.index_id
		INNER JOIN sys.columns AS sc ON sc.object_id = t.object_id AND sc.column_id = sic.column_id
		INNER JOIN sys.types AS sty ON sc.user_type_id = sty.user_type_id
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id) AS [KeyCols_data_length_bytes]
FROM sys.indexes AS mi
	INNER JOIN sys.tables AS mst ON mst.[object_id] = mi.[object_id]
	INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
	INNER JOIN sys.partitions AS p ON p.[object_id] = mi.[object_id] AND p.index_id = mi.index_id
WHERE mi.type IN (0,1,2,5,6) AND mst.is_ms_shipped = 0
ORDER BY mst.name
OPTION (MAXDOP 2);'

	INSERT INTO #tmpIxs
	EXECUTE sp_executesql @sqlcmd;

	IF @sqlmajorver >= 12
	BEGIN
		SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + DB_NAME(@dbid) + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], ''' + DB_NAME(@dbid) + ''' AS database_name,
	mst.[object_id], t.name, mst.[name], 
	mi.index_id, mi.[name], p.partition_number,
	mi.[type], mi.[type_desc], mi.is_primary_key, mi.is_unique_constraint, mi.is_disabled, 
	mi.fill_factor, mi.is_unique, mi.is_padded, mi.has_filter, mi.filter_definition,[bucket_count],
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS KeyCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS KeyColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS IncludedCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS IncludedColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS AllColsOrdered,
	(SELECT SUM(CASE sty.name WHEN ''nvarchar'' THEN sc.max_length/2 ELSE sc.max_length END) FROM sys.hash_indexes AS i
		INNER JOIN sys.tables AS t ON t.[object_id] = i.[object_id]
		INNER JOIN sys.schemas ss ON ss.[schema_id] = t.[schema_id]
		INNER JOIN sys.index_columns AS sic ON sic.object_id = mst.object_id AND sic.index_id = mi.index_id
		INNER JOIN sys.columns AS sc ON sc.object_id = t.object_id AND sc.column_id = sic.column_id
		INNER JOIN sys.types AS sty ON sc.user_type_id = sty.user_type_id
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id) AS [KeyCols_data_length_bytes]
FROM sys.hash_indexes AS mi
	INNER JOIN sys.tables AS mst ON mst.[object_id] = mi.[object_id]
	INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
	INNER JOIN sys.partitions AS p ON p.[object_id] = mi.[object_id] AND p.index_id = mi.index_id
WHERE mi.type IN (7) AND mst.is_ms_shipped = 0
ORDER BY mst.name
OPTION (MAXDOP 2);'

		INSERT INTO #tmpHashIxs
		EXECUTE sp_executesql @sqlcmd;
	END;
	
	UPDATE #tblDatabases
	SET is_done = 1
	WHERE database_id = @dbid;
END;

RAISERROR (N'Aggregating data...', 10, 1) WITH NOWAIT

INSERT INTO #tmpAgg
SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
	si.[schema_name], si.table_name, si.index_id, si.index_name, ISNULL(ps.partition_number, si.partition_number), 
	ps.fragmentation, si.fill_factor, ps.page_count, ps.[size_MB], ps.record_count, ps.forwarded_record_count, -- for heaps
	os.range_scan_count, os.singleton_lookup_count, os.forwarded_fetch_count, os.row_lock_count,
	os.row_lock_wait_count, os.row_lock_pct, os.row_lock_wait_in_ms, os.[avg_row_lock_waits_in_ms],
	os.page_lock_count, os.page_lock_wait_count, os.page_lock_pct, os.page_lock_wait_in_ms,
	os.[avg_page_lock_waits_in_ms], os.[page_io_latch_wait_in_ms], os.[avg_page_io_latch_wait_in_ms],
	s.[Hits], s.[Reads_Ratio], s.[Writes_Ratio], s.user_updates, s.last_user_seek, s.last_user_scan,
	s.last_user_lookup, s.last_user_update, si.KeyCols, si.KeyColsOrdered, si.IncludedCols,
	si.IncludedColsOrdered, si.AllColsOrdered, si.is_unique, si.[index_type], si.[type_desc],
	si.is_primary_key, si.is_unique_constraint, si.is_padded, si.has_filter, si.filter_definition,
	si.is_disabled,	si.[KeyCols_data_length_bytes]
FROM #tmpIxs AS si
	LEFT JOIN #tmpIPS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id] AND si.partition_number = ps.partition_number
	LEFT JOIN #tmpIOS AS os ON os.database_id = ps.database_id AND os.index_id = ps.index_id AND os.[object_id] = ps.[object_id] AND os.partition_number = ps.partition_number
	LEFT JOIN #tmpIUS AS s ON s.database_id = ps.database_id AND s.index_id = ps.index_id and s.[object_id] = ps.[object_id]
--WHERE si.type > 0 -- ignore heaps
ORDER BY database_name, [table_name], fragmentation DESC, index_id
OPTION (MAXDOP 2);

IF @sqlmajorver >= 12
BEGIN
	INSERT INTO #tmpAggXTPHash
	SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
		si.[schema_name], si.table_name, si.index_id, si.index_name, ps.total_bucket_count, ps.empty_bucket_count, 
		ps.avg_chain_length, ps.max_chain_length, ps.scans_started, ps.scans_retries, ps.rows_returned, 
		ps.rows_touched, si.KeyCols, si.KeyColsOrdered, si.IncludedCols, si.IncludedColsOrdered,
		si.AllColsOrdered, si.is_unique, si.[index_type], si.[type_desc], si.is_primary_key, si.is_unique_constraint,
		si.is_padded, si.has_filter, si.filter_definition, si.is_disabled, si.[KeyCols_data_length_bytes]	
	FROM #tmpHashIxs AS si
		LEFT JOIN #tmpXIS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id]
	ORDER BY database_name, [table_name], index_id
	OPTION (MAXDOP 2);

	INSERT INTO #tmpAggXTPNC
	SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
		si.[schema_name], si.table_name, si.index_id, si.index_name, ps.delta_pages, ps.internal_pages, 
		ps.leaf_pages, ps.page_update_count, ps.page_update_retry_count, 
		ps.page_consolidation_count, ps.page_consolidation_retry_count, ps.page_split_count, 
		ps.page_split_retry_count, ps.key_split_count, ps.key_split_retry_count, ps.page_merge_count, 
		ps.page_merge_retry_count, ps.key_merge_count, ps.key_merge_retry_count,
		ps.scans_started, ps.scans_retries, ps.rows_returned, ps.rows_touched,
		si.KeyCols, si.KeyColsOrdered, si.IncludedCols, si.IncludedColsOrdered, si.AllColsOrdered,
		si.is_unique, si.[index_type], si.[type_desc], si.is_primary_key, si.is_unique_constraint,
		si.is_padded, si.has_filter, si.filter_definition, si.is_disabled, si.[KeyCols_data_length_bytes]	
	FROM #tmpHashIxs AS si
		LEFT JOIN #tmpXNCIS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id]
	ORDER BY database_name, [table_name], index_id
	OPTION (MAXDOP 2);
END;
RAISERROR (N'Output index information', 10, 1) WITH NOWAIT

-- All index information
SELECT 'All_IX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
	[partition_number], fragmentation, fill_factor, [page_count], [size_MB], record_count, range_scan_count, singleton_lookup_count, row_lock_count, row_lock_wait_count,
	row_lock_pct, row_lock_wait_in_ms, [avg_row_lock_waits_in_ms], page_lock_count, page_lock_wait_count,
	page_lock_pct, page_lock_wait_in_ms, [avg_page_lock_waits_in_ms], page_io_latch_wait_in_ms, [avg_page_io_latch_wait_in_ms], [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	user_updates, last_user_seek, last_user_scan, last_user_lookup, last_user_update, KeyCols, IncludedCols,
	is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, filter_definition, KeyCols_data_length_bytes
FROM #tmpAgg
WHERE index_id > 0 -- ignore heaps
ORDER BY [database_name], [schema_name], table_name, [page_count] DESC, forwarded_record_count DESC;

-- All XTP index information
IF @sqlmajorver >= 12
BEGIN
	SELECT 'All_XTP_HashIX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
		total_bucket_count, empty_bucket_count, FLOOR((CAST(empty_bucket_count AS FLOAT)/total_bucket_count) * 100) AS [empty_bucket_pct], avg_chain_length, max_chain_length, 
		scans_started, scans_retries, rows_returned, rows_touched, KeyCols, IncludedCols, is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, 
		filter_definition, KeyCols_data_length_bytes
	FROM #tmpAggXTPHash
	ORDER BY [database_name], [schema_name], table_name, [total_bucket_count] DESC;

	SELECT 'All_XTP_RangeIX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
		delta_pages, internal_pages, leaf_pages, page_update_count, page_update_retry_count, page_consolidation_count, page_consolidation_retry_count, 
		page_split_count, page_split_retry_count, key_split_count, key_split_retry_count, page_merge_count, page_merge_retry_count, key_merge_count, key_merge_retry_count,
		scans_started, scans_retries, rows_returned, rows_touched, KeyCols, IncludedCols, is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, 
		filter_definition, KeyCols_data_length_bytes
	FROM #tmpAggXTPNC
	ORDER BY [database_name], [schema_name], table_name, [leaf_pages] DESC;
END;

-- All Heaps information
SELECT 'All_Heaps_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [type_desc] AS index_type,
	[partition_number], fragmentation, [page_count], [size_MB], record_count, forwarded_record_count, forwarded_fetch_count,
	range_scan_count, singleton_lookup_count, row_lock_count, row_lock_wait_count,
	row_lock_pct, row_lock_wait_in_ms, [avg_row_lock_waits_in_ms], page_lock_count, page_lock_wait_count,
	page_lock_pct, page_lock_wait_in_ms, [avg_page_lock_waits_in_ms], page_io_latch_wait_in_ms, [avg_page_io_latch_wait_in_ms]
FROM #tmpAgg
WHERE index_id = 0 -- only heaps
ORDER BY [database_name], [schema_name], table_name, [page_count] DESC, forwarded_record_count DESC;

-- Unused indexes that can possibly be dropped or disabled
SELECT 'Unused_IX_With_Updates' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] = 0 
	AND last_user_update > 0
	AND [type] IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
UNION ALL
SELECT 'Unused_IX_No_Updates' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] = 0 
	AND (last_user_update = 0 OR last_user_update IS NULL)
	AND [type] IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
ORDER BY [table_name], user_updates DESC, [page_count] DESC;

-- Rarely used indexes that can possibly be dropped or disabled
SELECT 'Rarely_Used_IX' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] > 0 AND [Reads_Ratio] < 5
	AND [type] IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
ORDER BY [database_name], [table_name], [page_count] DESC;

-- Duplicate Indexes
SELECT 'Duplicate_IX' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition, 
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[schema_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

/*
Note that it is possible that a clustered index (unique or not) is among the duplicate indexes to be dropped, 
namely if a non-clustered primary key exists on the table.
In this case, make the appropriate changes in the clustered index (making it unique and/or primary key in this case),
and drop the non-clustered instead.
*/
SELECT 'Duplicate_IX_toDrop' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition, 
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.[index_id] NOT IN (
			SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
			))
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

RAISERROR (N'Starting index search in sql modules...', 10, 1) WITH NOWAIT

DECLARE Dup_Stats CURSOR FAST_FORWARD FOR SELECT I.database_name,I.[index_name] 
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.[index_id] NOT IN (
			SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
			))
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

OPEN Dup_Stats
FETCH NEXT FROM Dup_Stats INTO @DatabaseName,@indexName
WHILE (@@FETCH_STATUS = 0)
BEGIN
	SET @sqlcmd = 'USE [' + @DatabaseName + '];
SELECT ''' + @DatabaseName + ''' AS [database_name], ss.name AS [schema_name], so.name AS [table_name], ''' + @indexName + ''' AS [index_name], so.type_desc
FROM sys.sql_modules sm
INNER JOIN sys.objects so ON sm.[object_id] = so.[object_id]
INNER JOIN sys.schemas ss ON ss.[schema_id] = so.[schema_id]
WHERE sm.[definition] LIKE ''%' + @indexName + '%'''

	INSERT INTO #tblCode
	EXECUTE sp_executesql @sqlcmd

	FETCH NEXT FROM Dup_Stats INTO @DatabaseName,@indexName
END
CLOSE Dup_Stats
DEALLOCATE Dup_Stats

RAISERROR (N'Ended index search in sql modules', 10, 1) WITH NOWAIT

SELECT 'Duplicate_Indexes_HardCoded' AS [Category], [DatabaseName], [schemaName], [objectName] AS [referedIn_objectName], 
	indexName AS [referenced_indexName], type_desc AS [refered_objectType]
FROM #tblCode
ORDER BY [DatabaseName], [objectName];

-- Redundant Indexes
SELECT 'Redundant_IX' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_unique, I.is_padded, I.has_filter, I.filter_definition,
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
ON I.[database_id] = I2.[database_id] AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND (((I.[KeyColsOrdered] <> I2.[KeyColsOrdered] OR I.IncludedColsOrdered <> I2.IncludedColsOrdered)
		AND ((CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END) = (CASE WHEN I2.IncludedColsOrdered IS NULL THEN I2.[KeyColsOrdered] ELSE I2.[KeyColsOrdered] + ',' + I2.IncludedColsOrdered END)
			OR I.[AllColsOrdered] = I2.[AllColsOrdered]))
	OR (I.[KeyColsOrdered] <> I2.[KeyColsOrdered] AND I.IncludedColsOrdered = I2.IncludedColsOrdered)
	OR (I.[KeyColsOrdered] = I2.[KeyColsOrdered] AND I.IncludedColsOrdered <> I2.IncludedColsOrdered)
	OR ((I.[AllColsOrdered] = I2.[AllColsOrdered] AND I.filter_definition IS NULL AND I2.filter_definition IS NOT NULL) OR (I.[AllColsOrdered] = I2.[AllColsOrdered] AND I.filter_definition IS NOT NULL AND I2.filter_definition IS NULL)))
	AND I.[index_id] NOT IN (SELECT I3.[index_id]
		FROM #tmpIxs I3 INNER JOIN #tmpIxs I4
		ON I3.[database_id] = I4.[database_id] AND I3.[object_id] = I4.[object_id] AND I3.[index_id] <> I4.[index_id] 
			AND I3.[KeyCols] = I4.[KeyCols] AND (I3.IncludedCols = I4.IncludedCols OR (I3.IncludedCols IS NULL AND I4.IncludedCols IS NULL))
		WHERE I3.[database_id] = I.[database_id] AND I3.[object_id] = I.[object_id]
		GROUP BY I3.[index_id])
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.is_unique_constraint = 0	-- no unique constraints
	AND I2.is_unique_constraint = 0	-- no unique constraints
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[AllColsOrdered], I.[index_id];

-- Large IX Keys
SELECT 'Large_Index_Key' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], 
	I.KeyCols, [KeyCols_data_length_bytes]
FROM #tmpAgg I
WHERE [KeyCols_data_length_bytes] > 900
ORDER BY I.[database_name], I.[schema_name], I.[table_name], I.[index_id];

-- Low Fill Factor
SELECT 'Low_Fill_Factor' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], 
	[fill_factor], I.KeyCols, I.IncludedCols, CASE WHEN I.IncludedCols IS NULL THEN I.[KeyCols] ELSE I.[KeyCols] + ',' + I.IncludedCols END AS [AllColsOrdered]
FROM #tmpAgg I
WHERE [fill_factor] BETWEEN 1 AND 79
ORDER BY I.[database_name], I.[schema_name], I.[table_name], I.[index_id];

--NonUnique Clustered IXs
SELECT 'NonUnique_CIXs' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[KeyCols]
FROM #tmpAgg I
WHERE [is_unique] = 0 
	AND I.[index_id] = 1
ORDER BY I.[database_name], I.[schema_name], I.[table_name];

RAISERROR (N'Generating scripts...', 10, 1) WITH NOWAIT

DECLARE @strSQL NVARCHAR(4000)
PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] = 0 AND last_user_update > 0) > 0
BEGIN
	PRINT CHAR(10) + '--############# Existing unused indexes with updates drop statements #############' + CHAR(10)
	DECLARE Un_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] = 0 AND last_user_update > 0
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC;

	OPEN Un_Stats
	FETCH NEXT FROM Un_Stats INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM Un_Stats INTO @strSQL
	END
	CLOSE Un_Stats
	DEALLOCATE Un_Stats
	PRINT CHAR(10) + '--############# Ended unused indexes with updates drop statements #############' + CHAR(10)
END;

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] = 0 AND (last_user_update = 0 OR last_user_update IS NULL)) > 0
BEGIN
	PRINT CHAR(10) + '--############# Existing unused indexes with no updates drop statements #############' + CHAR(10)
	DECLARE Un_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] = 0 AND (last_user_update = 0 OR last_user_update IS NULL)
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC;

	OPEN Un_Stats
	FETCH NEXT FROM Un_Stats INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM Un_Stats INTO @strSQL
	END
	CLOSE Un_Stats
	DEALLOCATE Un_Stats
	PRINT CHAR(10) + '--############# Ended unused indexes with no updates drop statements #############' + CHAR(10)
END;

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] > 0 AND [Reads_Ratio] < 5) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'
	PRINT CHAR(10) + '--############# Existing rarely used indexes drop statements #############' + CHAR(10)
	DECLARE curRarUsed CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] > 0 AND [Reads_Ratio] < 5
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC

	OPEN curRarUsed
	FETCH NEXT FROM curRarUsed INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM curRarUsed INTO @strSQL
	END
	CLOSE curRarUsed
	DEALLOCATE curRarUsed
	PRINT '--############# Ended rarely used indexes drop statements #############' + CHAR(10)
END;

PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'
PRINT CHAR(10) + '/*
NOTE: It is possible that a clustered index (unique or not) is among the duplicate indexes to be dropped, namely if a non-clustered primary key exists on the table.
In this case, make the appropriate changes in the clustered index (making it unique and/or primary key in this case), and drop the non-clustered instead.
*/'
PRINT CHAR(10) + '--############# Existing Duplicate indexes drop statements #############' + CHAR(10)
DECLARE Dup_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + I.[database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ I.[index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME(I.[index_name]) + ' ON ' + QUOTENAME(I.[schema_name]) + '.' + QUOTENAME(I.[table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg I INNER JOIN #tmpAgg I2
		ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
		AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
		AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
	WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
		AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
		AND I.[index_id] NOT IN (
				SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
					AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
				(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
					AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
				(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
				))
	GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
	ORDER BY I.database_name, I.[table_name], I.[index_id];
OPEN Dup_Stats
FETCH NEXT FROM Dup_Stats INTO @strSQL
WHILE (@@FETCH_STATUS = 0)
BEGIN
	PRINT @strSQL
	FETCH NEXT FROM Dup_Stats INTO @strSQL
END
CLOSE Dup_Stats
DEALLOCATE Dup_Stats
PRINT '--############# Ended Duplicate indexes drop statements #############' + CHAR(10)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
DROP TABLE #tmpIPS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
DROP TABLE #tmpIOS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
DROP TABLE #tmpIUS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
DROP TABLE #tmpXIS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
DROP TABLE #tmpXNCIS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
DROP TABLE #tmpIxs;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
DROP TABLE #tmpHashIxs;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
DROP TABLE #tmpAgg;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
DROP TABLE #tmpAggXTPHash;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
DROP TABLE #tmpAggXTPNC;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
DROP TABLE #tblWorking;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
DROP TABLE #tblCode;
GO

---view_IndexInformation_CurrentDB.sql

-- 2012-03-19 Pedro Lopes (Microsoft) pedro.lopes@microsoft.com (http://aka.ms/ezequiel)
--
-- All Databases index info, including duplicate, redundant, rarely used and unused indexes.
--
-- 4/5/2012		Simplified execution by subdividing input queries
-- 4/5/2012		Fixed some collation issues;
-- 4/6/2012		Split in separate listings the unused indexes from rarely used indexes; Split in separate list
-- 6/6/2012		Fixed issue with partition aligned indexes
-- 10/31/2012	Widened search for Redundant Indexes
-- 12/17/2012	Fixed several issues
-- 1/17/2013	Added several index related info
-- 2/1/2013		Fixed issue with Heap identification
-- 2/26/2013	Fixed issue with partition info; Removed alternate keys from search for Unused and Rarely used
-- 4/17/2013	Added more information to duplicate and redundant indexes output, valuable when deciding which
-- 4/19/2013	Fixed issue with potential duplicate index_ids in sys.dm_db_index_operational_stats relating t
-- 5/6/2013		Changed data collection to minimize blocking potential on VLDBs.
-- 5/20/2013	Fixed issue with database names with special characters.
-- 5/29/2013	Fixed issue with large integers in aggregation.
-- 6/20/2013	Added step to avoid entering in loop that generates dump in SQL 2005.
-- 11/10/2013	Added index checks.
-- 2/24/2014	Added info to Unused_IX section.
-- 6/4/2014		Refined search for duplicate and redundant indexes.
-- 11/12/2014	Added SQL 2014 Hash indexes support; changed scan mode to LIMITED; added search for hard coded
-- 11/2/2016	Added support for SQL Server 2016 sys.dm_db_index_operational_stats changes; Added script creation.
/*
NOTE: on SQL Server 2005, be aware that querying sys.dm_db_index_usage_stats when it has large number of rows may lead to performance issues.
URL: http://support.microsoft.com/kb/2003031
*/

SET NOCOUNT ON;

DECLARE @UpTime VARCHAR(12), @StartDate DATETIME, @sqlmajorver int, @sqlcmd NVARCHAR(4000), @params NVARCHAR(500)
DECLARE @DatabaseName sysname, @indexName sysname
SELECT @sqlmajorver = CONVERT(int, (@@microsoftversion / 0x1000000) & 0xff);

IF @sqlmajorver = 9
BEGIN
	SET @sqlcmd = N'SELECT @StartDateOUT = login_time, @UpTimeOUT = DATEDIFF(mi, login_time, GETDATE()) FROM master..sysprocesses WHERE spid = 1';
END
ELSE
BEGIN
	SET @sqlcmd = N'SELECT @StartDateOUT = sqlserver_start_time, @UpTimeOUT = DATEDIFF(mi,sqlserver_start_time,GETDATE()) FROM sys.dm_os_sys_info';
END

SET @params = N'@StartDateOUT DATETIME OUTPUT, @UpTimeOUT VARCHAR(12) OUTPUT';

EXECUTE sp_executesql @sqlcmd, @params, @StartDateOUT=@StartDate OUTPUT, @UpTimeOUT=@UpTime OUTPUT;

SELECT @StartDate AS Collecting_Data_Since, CONVERT(VARCHAR(4),@UpTime/60/24) + 'd ' + CONVERT(VARCHAR(4),@UpTime/60%24) + 'h ' + CONVERT(VARCHAR(4),@UpTime%60) + 'm' AS Collecting_Data_For

RAISERROR (N'Starting...', 10, 1) WITH NOWAIT

DECLARE @dbid int, @dbname NVARCHAR(255)--, @sqlcmd NVARCHAR(4000)
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblDatabases'))
DROP TABLE #tblDatabases;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblDatabases'))
CREATE TABLE #tblDatabases (database_id int PRIMARY KEY, is_done bit)

SET @dbid = DB_ID()
SELECT @dbname = DB_NAME()

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
DROP TABLE #tblWorking;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
CREATE TABLE #tblWorking (database_id int, [object_id] int, [object_name] NVARCHAR(255), index_id int, index_name NVARCHAR(255), [schema_name] NVARCHAR(255), partition_number int, is_done bit)

RAISERROR (N'Populating support tables...', 10, 1) WITH NOWAIT

SELECT @sqlcmd = 'USE [' + @dbname + '];
SELECT DISTINCT ' + CONVERT(NVARCHAR(255), @dbid) + ', si.[object_id], mst.[name], si.index_id, si.name, t.name, sp.partition_number, 0
FROM sys.indexes si
INNER JOIN sys.partitions sp ON si.[object_id] = sp.[object_id] AND si.index_id = sp.index_id
INNER JOIN sys.tables AS mst ON mst.[object_id] = si.[object_id]
INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
WHERE mst.is_ms_shipped = 0'

INSERT INTO #tblWorking
EXEC sp_executesql @sqlcmd;

--------------------------------------------------------
-- Index physical and usage stats
--------------------------------------------------------
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
DROP TABLE #tmpIPS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
CREATE TABLE #tmpIPS (
	[database_id] int,
	[object_id] int,
	[index_id] int,
	[partition_number] int,
	fragmentation DECIMAL(18,3),
	[page_count] bigint,
	[size_MB] DECIMAL(26,3),
	record_count int,
	forwarded_record_count int NULL,
	CONSTRAINT PK_IPS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]))

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
DROP TABLE #tmpIOS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
CREATE TABLE #tmpIOS (
	[database_id] int,
	[object_id] int,
	[index_id] int,
	[partition_number] int,
	range_scan_count bigint NULL,
	singleton_lookup_count bigint NULL,
	forwarded_fetch_count bigint NULL,
	row_lock_count bigint NULL,
	row_lock_wait_count bigint NULL,
	row_lock_pct NUMERIC(15,2) NULL,
	row_lock_wait_in_ms bigint NULL,
	[avg_row_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_lock_count bigint NULL,
	page_lock_wait_count bigint NULL,
	page_lock_pct NUMERIC(15,2) NULL,
	page_lock_wait_in_ms bigint NULL,
	[avg_page_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_io_latch_wait_in_ms bigint NULL,
	[avg_page_io_latch_wait_in_ms] NUMERIC(15,2) NULL
	CONSTRAINT PK_IOS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
DROP TABLE #tmpIUS;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
CREATE TABLE #tmpIUS (
	[database_id] int,
	[schema_name] VARCHAR(100) COLLATE database_default,
	[object_id] int,
	[index_id] int,
	[Hits] bigint NULL,
	[Reads_Ratio] DECIMAL(5,2),
	[Writes_Ratio] DECIMAL(5,2),
	user_updates bigint,
	last_user_seek DATETIME NULL,
	last_user_scan DATETIME NULL,
	last_user_lookup DATETIME NULL,
	last_user_update DATETIME NULL
	CONSTRAINT PK_IUS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
DROP TABLE #tmpIxs;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
CREATE TABLE #tmpIxs (
	[database_id] int, 
	[database_name] VARCHAR(500), 
	[object_id] int, 
	[schema_name] VARCHAR(100) COLLATE database_default, 
	[table_name] VARCHAR(300) COLLATE database_default, 
	[index_id] int, 
	[index_name] VARCHAR(300) COLLATE database_default,
	[partition_number] int,
	[index_type] tinyint,
	type_desc NVARCHAR(30),
	is_primary_key bit,
	is_unique_constraint bit,
	is_disabled bit,
	fill_factor tinyint, 
	is_unique bit, 
	is_padded bit, 
	has_filter bit,
	filter_definition NVARCHAR(max),
	KeyCols VARCHAR(4000), 
	KeyColsOrdered VARCHAR(4000), 
	IncludedCols VARCHAR(4000) NULL, 
	IncludedColsOrdered VARCHAR(4000) NULL, 
	AllColsOrdered VARCHAR(4000) NULL,
	[KeyCols_data_length_bytes] int,
	CONSTRAINT PK_Ixs PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
DROP TABLE #tmpAgg;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
CREATE TABLE #tmpAgg (
	[database_id] int,
	[database_name] sysname,
	[object_id] int,
	[schema_name] VARCHAR(100) COLLATE database_default,
	[table_name] VARCHAR(300) COLLATE database_default,
	[index_id] int,
	[index_name] VARCHAR(300) COLLATE database_default,
	[partition_number] int,
	fragmentation DECIMAL(18,3),
	fill_factor tinyint,
	[page_count] bigint,
	[size_MB] DECIMAL(26,3),
	record_count bigint, 
	forwarded_record_count bigint NULL,
	range_scan_count bigint NULL,
	singleton_lookup_count bigint NULL,
	forwarded_fetch_count bigint NULL,
	row_lock_count bigint NULL,
	row_lock_wait_count bigint NULL,
	row_lock_pct NUMERIC(15,2) NULL,
	row_lock_wait_in_ms bigint NULL,
	[avg_row_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_lock_count bigint NULL,
	page_lock_wait_count bigint NULL,
	page_lock_pct NUMERIC(15,2) NULL,
	page_lock_wait_in_ms bigint NULL,
	[avg_page_lock_waits_in_ms] NUMERIC(15,2) NULL,
	page_io_latch_wait_in_ms bigint NULL,
	[avg_page_io_latch_wait_in_ms] NUMERIC(15,2) NULL,
	[Hits] bigint NULL,
	[Reads_Ratio] DECIMAL(5,2),
	[Writes_Ratio] DECIMAL(5,2),
	user_updates bigint,
	last_user_seek DATETIME NULL,
	last_user_scan DATETIME NULL,
	last_user_lookup DATETIME NULL,
	last_user_update DATETIME NULL,
	KeyCols VARCHAR(4000) COLLATE database_default,
	KeyColsOrdered VARCHAR(4000) COLLATE database_default,
	IncludedCols VARCHAR(4000) COLLATE database_default NULL,
	IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
	AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
	is_unique bit,
	[type] tinyint,
	type_desc NVARCHAR(30),
	is_primary_key bit,
	is_unique_constraint bit,
	is_padded bit, 
	has_filter bit, 
	filter_definition NVARCHAR(max),
	is_disabled bit,
	[KeyCols_data_length_bytes] int,	
	CONSTRAINT PK_tmpIxs PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
DROP TABLE #tblCode;
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
CREATE TABLE #tblCode (
	[DatabaseName] sysname, 
	[schemaName] VARCHAR(100), 
	[objectName] VARCHAR(200), 
	[indexName] VARCHAR(200), 
	type_desc NVARCHAR(60));

IF @sqlmajorver >= 12
BEGIN
	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
	DROP TABLE #tmpXIS;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
	CREATE TABLE #tmpXIS (
		[database_id] int,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		total_bucket_count bigint, 
		empty_bucket_count bigint, 
		avg_chain_length bigint, 
		max_chain_length bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		CONSTRAINT PK_tmpXIS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
	DROP TABLE #tmpXNCIS;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
	CREATE TABLE #tmpXNCIS (
		[database_id] int,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		delta_pages bigint, 
		internal_pages bigint, 
		leaf_pages bigint, 
		page_update_count bigint,
		page_update_retry_count bigint, 
		page_consolidation_count bigint,
		page_consolidation_retry_count bigint, 
		page_split_count bigint, 
		page_split_retry_count bigint,
		key_split_count bigint, 
		key_split_retry_count bigint, 
		page_merge_count bigint, 
		page_merge_retry_count bigint,
		key_merge_count bigint, 
		key_merge_retry_count bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		CONSTRAINT PK_tmpXNCIS PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
	DROP TABLE #tmpAggXTPHash;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
	CREATE TABLE #tmpAggXTPHash (
		[database_id] int,
		[database_name] sysname,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		total_bucket_count bigint, 
		empty_bucket_count bigint, 
		avg_chain_length bigint, 
		max_chain_length bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		KeyCols VARCHAR(4000) COLLATE database_default,
		KeyColsOrdered VARCHAR(4000) COLLATE database_default,
		IncludedCols VARCHAR(4000) COLLATE database_default NULL,
		IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
		AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
		is_unique bit,
		[type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_padded bit, 
		has_filter bit, 
		filter_definition NVARCHAR(max),
		is_disabled bit,
		[KeyCols_data_length_bytes] int,	
		CONSTRAINT PK_tmpAggXTPHash PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
	DROP TABLE #tmpAggXTPNC;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
	CREATE TABLE #tmpAggXTPNC (
		[database_id] int,
		[database_name] sysname,
		[object_id] int,
		[schema_name] VARCHAR(100) COLLATE database_default,
		[table_name] VARCHAR(300) COLLATE database_default,
		[index_id] int,
		[index_name] VARCHAR(300) COLLATE database_default,
		delta_pages bigint, 
		internal_pages bigint, 
		leaf_pages bigint, 
		page_update_count bigint,
		page_update_retry_count bigint, 
		page_consolidation_count bigint,
		page_consolidation_retry_count bigint, 
		page_split_count bigint, 
		page_split_retry_count bigint,
		key_split_count bigint, 
		key_split_retry_count bigint, 
		page_merge_count bigint, 
		page_merge_retry_count bigint,
		key_merge_count bigint, 
		key_merge_retry_count bigint, 
		scans_started bigint, 
		scans_retries bigint, 
		rows_returned bigint, 
		rows_touched bigint,
		KeyCols VARCHAR(4000) COLLATE database_default,
		KeyColsOrdered VARCHAR(4000) COLLATE database_default,
		IncludedCols VARCHAR(4000) COLLATE database_default NULL,
		IncludedColsOrdered VARCHAR(4000) COLLATE database_default NULL, 
		AllColsOrdered VARCHAR(4000) COLLATE database_default NULL,
		is_unique bit,
		[type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_padded bit,
		has_filter bit,
		filter_definition NVARCHAR(max),
		is_disabled bit,
		[KeyCols_data_length_bytes] int,	
		CONSTRAINT PK_tmpAggXTPNC PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id]));

	IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
	DROP TABLE #tmpHashIxs;
	IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
	CREATE TABLE #tmpHashIxs (
		[database_id] int, 
		[database_name] VARCHAR(500), 
		[object_id] int, 
		[schema_name] VARCHAR(100) COLLATE database_default, 
		[table_name] VARCHAR(300) COLLATE database_default, 
		[index_id] int, 
		[index_name] VARCHAR(300) COLLATE database_default,
		[partition_number] int,
		[index_type] tinyint,
		type_desc NVARCHAR(30),
		is_primary_key bit,
		is_unique_constraint bit,
		is_disabled bit,
		fill_factor tinyint, 
		is_unique bit, 
		is_padded bit, 
		has_filter bit,
		filter_definition NVARCHAR(max),
		[bucket_count] bigint,
		KeyCols VARCHAR(4000), 
		KeyColsOrdered VARCHAR(4000), 
		IncludedCols VARCHAR(4000) NULL, 
		IncludedColsOrdered VARCHAR(4000) NULL, 
		AllColsOrdered VARCHAR(4000) NULL,
		[KeyCols_data_length_bytes] int,
		CONSTRAINT PK_HashIxs PRIMARY KEY CLUSTERED(database_id, [object_id], [index_id], [partition_number]));
END;

DECLARE /*@dbid int, */@objectid int, @indexid int, @partition_nr int, /*@dbname NVARCHAR(255),*/ @oname NVARCHAR(255), @iname NVARCHAR(255), @sname NVARCHAR(255)

RAISERROR (N'Gathering sys.dm_db_index_physical_stats and sys.dm_db_index_operational_stats data...', 10, 1) WITH NOWAIT

WHILE (SELECT COUNT(*) FROM #tblWorking WHERE is_done = 0) > 0
BEGIN
	SELECT TOP 1 @objectid = [object_id], @indexid = index_id, @partition_nr = partition_number, @oname = [object_name], @iname = index_name, @sname = [schema_name]
	FROM #tblWorking WHERE is_done = 0

	INSERT INTO #tmpIPS
	SELECT ps.database_id, 
		ps.[object_id], 
		ps.index_id, 
		ps.partition_number, 
		SUM(ps.avg_fragmentation_in_percent),
		SUM(ps.page_count),
		CAST((SUM(ps.page_count)*8)/1024 AS DECIMAL(26,3)) AS [size_MB],
		SUM(ISNULL(ps.record_count,0)),
		SUM(ISNULL(ps.forwarded_record_count,0)) -- for heaps
	FROM sys.dm_db_index_physical_stats(@dbid, @objectid, @indexid , @partition_nr, 'SAMPLED') AS ps
	WHERE /*ps.index_id > 0 -- ignore heaps
		AND */ps.index_level = 0 -- leaf-level nodes only
		AND ps.alloc_unit_type_desc = 'IN_ROW_DATA'
	GROUP BY ps.database_id, ps.[object_id], ps.index_id, ps.partition_number
	OPTION (MAXDOP 2);

	-- Avoid entering in loop that generates dump in SQL 2005
	IF @sqlmajorver = 9
	BEGIN
		SET @sqlcmd = (SELECT 'USE [' + @dbname + '];
UPDATE STATISTICS ' + QUOTENAME(@sname) + '.' + QUOTENAME(@oname) + CASE WHEN @iname IS NULL THEN '' ELSE ' (' + QUOTENAME(@iname) + ')' END)
		EXEC sp_executesql @sqlcmd
	END;

	SET @sqlcmd = N'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
WITH osCTE (database_id, [object_id], index_id, partition_number, range_scan_count, singleton_lookup_count, 
	forwarded_fetch_count, row_lock_count, row_lock_wait_count, row_lock_wait_in_ms, page_lock_count, 
	page_lock_wait_count, page_lock_wait_in_ms, page_io_latch_wait_count, page_io_latch_wait_in_ms)
AS (SELECT os.database_id, 
	os.[object_id], 
	os.index_id,
	os.partition_number, 
	SUM(os.range_scan_count), 
	SUM(os.singleton_lookup_count),
	SUM(os.forwarded_fetch_count),
	SUM(os.row_lock_count),
	SUM(os.row_lock_wait_count),
	SUM(os.row_lock_wait_in_ms),
	SUM(os.page_lock_count),
	SUM(os.page_lock_wait_count),
	SUM(os.page_lock_wait_in_ms),
	SUM(os.page_io_latch_wait_count),
	SUM(os.page_io_latch_wait_in_ms)
FROM sys.dm_db_index_operational_stats(' + CONVERT(NVARCHAR(20), @dbid) + ', ' + CONVERT(NVARCHAR(20), @objectid) + ', ' + CONVERT(NVARCHAR(20), @indexid) + ', ' + CONVERT(NVARCHAR(20), @partition_nr) + ') AS os
INNER JOIN sys.objects AS o WITH (NOLOCK) ON os.[object_id] = o.[object_id]
' + CASE WHEN @sqlmajorver >= 13 THEN 'LEFT JOIN sys.internal_partitions AS ip WITH (NOLOCK) ON os.hobt_id = ip.hobt_id AND ip.internal_object_type IN (2,3)' ELSE '' END + '
WHERE o.[type] = ''U''
GROUP BY os.database_id, os.[object_id], os.index_id, os.partition_number
)
SELECT osCTE.database_id, 
	osCTE.[object_id], 
	osCTE.index_id,
	osCTE.partition_number, 
	osCTE.range_scan_count, 
	osCTE.singleton_lookup_count,
	osCTE.forwarded_fetch_count,
	osCTE.row_lock_count,
	osCTE.row_lock_wait_count,
	CAST(100.0 * osCTE.row_lock_wait_count / (1 + osCTE.row_lock_count) AS numeric(15,2)) AS row_lock_pct,
	osCTE.row_lock_wait_in_ms,
	CAST(1.0 * osCTE.row_lock_wait_in_ms / (1 + osCTE.row_lock_wait_count) AS numeric(15,2)) AS [avg_row_lock_waits_in_ms],
	osCTE.page_lock_count,
	osCTE.page_lock_wait_count,
	CAST(100.0 * osCTE.page_lock_wait_count / (1 + osCTE.page_lock_count) AS numeric(15,2)) AS page_lock_pct,
	osCTE.page_lock_wait_in_ms,
	CAST(1.0 * osCTE.page_lock_wait_in_ms / (1 + osCTE.page_lock_wait_count) AS numeric(15,2)) AS [avg_page_lock_waits_in_ms],
	osCTE.page_io_latch_wait_in_ms,
	CAST(1.0 * osCTE.page_io_latch_wait_in_ms / (1 + osCTE.page_io_latch_wait_count) AS numeric(15,2)) AS [avg_page_io_latch_wait_in_ms]
FROM osCTE
--WHERE os.index_id > 0 -- ignore heaps
OPTION (MAXDOP 2);'

	INSERT INTO #tmpIOS
	EXEC sp_executesql @sqlcmd

	UPDATE #tblWorking
	SET is_done = 1
	WHERE [object_id] = @objectid AND index_id = @indexid AND partition_number = @partition_nr
END;

IF @sqlmajorver >= 12
BEGIN
	RAISERROR (N'Gathering sys.dm_db_xtp_hash_index_stats and sys.dm_db_xtp_nonclustered_index_stats data...', 10, 1) WITH NOWAIT

	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], xis.[object_id], t.name, o.name, xis.index_id, si.name, 
	xhis.total_bucket_count, xhis.empty_bucket_count, xhis.avg_chain_length, xhis.max_chain_length, 
	xis.scans_started, xis.scans_retries, xis.rows_returned, xis.rows_touched
FROM sys.dm_db_xtp_hash_index_stats xhis
INNER JOIN sys.dm_db_xtp_index_stats xis ON xis.[object_id] = xhis.[object_id] AND xis.[index_id] = xhis.[index_id] 
INNER JOIN sys.indexes AS si WITH (NOLOCK) ON xis.[object_id] = si.[object_id] AND xis.[index_id] = si.[index_id]
INNER JOIN sys.objects AS o WITH (NOLOCK) ON si.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = o.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U'''

	INSERT INTO #tmpXIS
	EXECUTE sp_executesql @sqlcmd

	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id],
	xis.[object_id], t.name, o.name, xis.index_id, si.name, 
	xnis.delta_pages, xnis.internal_pages, xnis.leaf_pages, xnis.page_update_count,
	xnis.page_update_retry_count, xnis.page_consolidation_count,
	xnis.page_consolidation_retry_count, xnis.page_split_count, xnis.page_split_retry_count,
	xnis.key_split_count, xnis.key_split_retry_count, xnis.page_merge_count, xnis.page_merge_retry_count,
	xnis.key_merge_count, xnis.key_merge_retry_count,
	xis.scans_started, xis.scans_retries, xis.rows_returned, xis.rows_touched
FROM sys.dm_db_xtp_nonclustered_index_stats AS xnis WITH (NOLOCK)
INNER JOIN sys.dm_db_xtp_index_stats AS xis WITH (NOLOCK) ON xis.[object_id] = xnis.[object_id] AND xis.[index_id] = xnis.[index_id]
INNER JOIN sys.indexes AS si WITH (NOLOCK) ON xis.[object_id] = si.[object_id] AND xis.[index_id] = si.[index_id]
INNER JOIN sys.objects AS o WITH (NOLOCK) ON si.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = o.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U'''
	
	INSERT INTO #tmpXNCIS
	EXECUTE sp_executesql @sqlcmd
END;
	
RAISERROR (N'Gathering sys.dm_db_index_usage_stats data...', 10, 1) WITH NOWAIT

SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT s.database_id, t.name, s.[object_id], s.index_id,
	(s.user_seeks + s.user_scans + s.user_lookups) AS [Hits],
	RTRIM(CONVERT(NVARCHAR(20),CAST(CASE WHEN (s.user_seeks + s.user_scans + s.user_lookups) = 0 THEN 0 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups)) * 100 /
		CASE (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates) WHEN 0 THEN 1 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates)) END END AS DECIMAL(18,2))) COLLATE database_default) AS [Reads_Ratio],
	RTRIM(CONVERT(NVARCHAR(20),CAST(CASE WHEN s.user_updates = 0 THEN 0 ELSE CONVERT(REAL, s.user_updates) * 100 /
		CASE (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates) WHEN 0 THEN 1 ELSE CONVERT(REAL, (s.user_seeks + s.user_scans + s.user_lookups + s.user_updates)) END END AS DECIMAL(18,2))) COLLATE database_default) AS [Writes_Ratio],
	s.user_updates,
	MAX(s.last_user_seek) AS last_user_seek,
	MAX(s.last_user_scan) AS last_user_scan,
	MAX(s.last_user_lookup) AS last_user_lookup,
	MAX(s.last_user_update) AS last_user_update
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.objects AS o WITH (NOLOCK) ON s.[object_id] = o.[object_id]
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = s.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U''
	AND s.database_id = ' + CONVERT(NVARCHAR(20), @dbid) + ' 
	--AND s.index_id > 0 -- ignore heaps
GROUP BY s.database_id, t.name, s.[object_id], s.index_id, s.user_seeks, s.user_scans, s.user_lookups, s.user_updates
OPTION (MAXDOP 2)'

INSERT INTO #tmpIUS
EXECUTE sp_executesql @sqlcmd

SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], t.name, i.[object_id], i.index_id, 0, 0, 0, NULL, NULL, NULL, NULL, NULL
FROM sys.indexes i WITH (NOLOCK)
INNER JOIN sys.objects o WITH (NOLOCK) ON i.object_id = o.object_id 
INNER JOIN sys.tables AS mst WITH (NOLOCK) ON mst.[object_id] = i.[object_id]
INNER JOIN sys.schemas AS t WITH (NOLOCK) ON t.[schema_id] = mst.[schema_id]
WHERE o.[type] = ''U'' 
	AND i.index_id NOT IN (SELECT s.index_id
	FROM sys.dm_db_index_usage_stats s WITH (NOLOCK)
	WHERE s.object_id = i.object_id 
		AND i.index_id = s.index_id 
		AND database_id = ' + CONVERT(NVARCHAR(20), @dbid) + ')
		AND i.name IS NOT NULL
		AND i.index_id > 1'

INSERT INTO #tmpIUS
EXECUTE sp_executesql @sqlcmd

RAISERROR (N'Gathering index column data...', 10, 1) WITH NOWAIT

SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], ''' + @dbname + ''' AS database_name,
	mst.[object_id], t.name, mst.[name], 
	mi.index_id, mi.[name], p.partition_number,
	mi.[type], mi.[type_desc], mi.is_primary_key, mi.is_unique_constraint, mi.is_disabled, 
	mi.fill_factor, mi.is_unique, mi.is_padded, ' + CASE WHEN @sqlmajorver > 9 THEN 'mi.has_filter, mi.filter_definition,' ELSE 'NULL, NULL,' END + '
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS KeyCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS KeyColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS IncludedCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS IncludedColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS AllColsOrdered,
	(SELECT SUM(CASE sty.name WHEN ''nvarchar'' THEN sc.max_length/2 ELSE sc.max_length END) FROM sys.indexes AS i
		INNER JOIN sys.tables AS t ON t.[object_id] = i.[object_id]
		INNER JOIN sys.schemas ss ON ss.[schema_id] = t.[schema_id]
		INNER JOIN sys.index_columns AS sic ON sic.object_id = mst.object_id AND sic.index_id = mi.index_id
		INNER JOIN sys.columns AS sc ON sc.object_id = t.object_id AND sc.column_id = sic.column_id
		INNER JOIN sys.types AS sty ON sc.user_type_id = sty.user_type_id
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id) AS [KeyCols_data_length_bytes]
FROM sys.indexes AS mi 
	INNER JOIN sys.tables AS mst ON mst.[object_id] = mi.[object_id]
	INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
	INNER JOIN sys.partitions AS p ON p.[object_id] = mi.[object_id] AND p.index_id = mi.index_id
WHERE mi.type IN (0,1,2,5,6) AND mst.is_ms_shipped = 0
OPTION (MAXDOP 2);'

INSERT INTO #tmpIxs
EXECUTE sp_executesql @sqlcmd;

IF @sqlmajorver >= 12
BEGIN
	SET @sqlcmd = 'SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
USE [' + @dbname + '];
SELECT ' + CONVERT(NVARCHAR(20), @dbid) + ' AS [database_id], ''' + @dbname + ''' AS database_name,
	mst.[object_id], t.name, mst.[name], 
	mi.index_id, mi.[name], p.partition_number,
	mi.[type], mi.[type_desc], mi.is_primary_key, mi.is_unique_constraint, mi.is_disabled, 
	mi.fill_factor, mi.is_unique, mi.is_padded, mi.has_filter, mi.filter_definition,[bucket_count],
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS KeyCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id] 
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 0
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS KeyColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ic.key_ordinal
	FOR XML PATH('''')), 2, 8000) AS IncludedCols,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id AND ic.is_included_column = 1
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS IncludedColsOrdered,
	SUBSTRING((SELECT '','' + ac.name FROM sys.tables AS st
		INNER JOIN sys.hash_indexes AS i ON st.[object_id] = i.[object_id]
		INNER JOIN sys.index_columns AS ic ON i.[object_id] = ic.[object_id] AND i.[index_id] = ic.[index_id]
		INNER JOIN sys.all_columns AS ac ON st.[object_id] = ac.[object_id] AND ic.[column_id] = ac.[column_id]
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id
		ORDER BY ac.name
	FOR XML PATH('''')), 2, 8000) AS AllColsOrdered,
	(SELECT SUM(CASE sty.name WHEN ''nvarchar'' THEN sc.max_length/2 ELSE sc.max_length END) FROM sys.hash_indexes AS i
		INNER JOIN sys.tables AS t ON t.[object_id] = i.[object_id]
		INNER JOIN sys.schemas ss ON ss.[schema_id] = t.[schema_id]
		INNER JOIN sys.index_columns AS sic ON sic.object_id = mst.object_id AND sic.index_id = mi.index_id
		INNER JOIN sys.columns AS sc ON sc.object_id = t.object_id AND sc.column_id = sic.column_id
		INNER JOIN sys.types AS sty ON sc.user_type_id = sty.user_type_id
		WHERE mi.[object_id] = i.[object_id] AND mi.index_id = i.index_id) AS [KeyCols_data_length_bytes]
FROM sys.hash_indexes AS mi
	INNER JOIN sys.tables AS mst ON mst.[object_id] = mi.[object_id]
	INNER JOIN sys.schemas AS t ON t.[schema_id] = mst.[schema_id]
	INNER JOIN sys.partitions AS p ON p.[object_id] = mi.[object_id] AND p.index_id = mi.index_id
WHERE mi.type IN (7) AND mst.is_ms_shipped = 0
ORDER BY mst.name
OPTION (MAXDOP 2);'

	INSERT INTO #tmpHashIxs
	EXECUTE sp_executesql @sqlcmd;
END;

RAISERROR (N'Aggregating data...', 10, 1) WITH NOWAIT

INSERT INTO #tmpAgg
SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
	si.[schema_name], si.table_name, si.index_id, si.index_name, ISNULL(ps.partition_number, si.partition_number), 
	ps.fragmentation, si.fill_factor, ps.page_count, ps.[size_MB], ps.record_count, ps.forwarded_record_count, -- for heaps
	os.range_scan_count, os.singleton_lookup_count, os.forwarded_fetch_count, os.row_lock_count,
	os.row_lock_wait_count, os.row_lock_pct, os.row_lock_wait_in_ms, os.[avg_row_lock_waits_in_ms],
	os.page_lock_count, os.page_lock_wait_count, os.page_lock_pct, os.page_lock_wait_in_ms,
	os.[avg_page_lock_waits_in_ms], os.[page_io_latch_wait_in_ms], os.[avg_page_io_latch_wait_in_ms],
	s.[Hits], s.[Reads_Ratio], s.[Writes_Ratio], s.user_updates, s.last_user_seek, s.last_user_scan,
	s.last_user_lookup, s.last_user_update, si.KeyCols, si.KeyColsOrdered, si.IncludedCols,
	si.IncludedColsOrdered, si.AllColsOrdered, si.is_unique, si.[index_type], si.[type_desc],
	si.is_primary_key, si.is_unique_constraint, si.is_padded, si.has_filter, si.filter_definition,
	si.is_disabled,	si.[KeyCols_data_length_bytes]
FROM #tmpIxs AS si
	LEFT JOIN #tmpIPS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id] AND si.partition_number = ps.partition_number
	LEFT JOIN #tmpIOS AS os ON os.database_id = ps.database_id AND os.index_id = ps.index_id AND os.[object_id] = ps.[object_id] AND os.partition_number = ps.partition_number
	LEFT JOIN #tmpIUS AS s ON s.database_id = ps.database_id AND s.index_id = ps.index_id and s.[object_id] = ps.[object_id]
--WHERE si.type > 0 -- ignore heaps
ORDER BY database_name, [table_name], fragmentation DESC, index_id
OPTION (MAXDOP 2);

IF @sqlmajorver >= 12
BEGIN
	INSERT INTO #tmpAggXTPHash
	SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
		si.[schema_name], si.table_name, si.index_id, si.index_name, ps.total_bucket_count, ps.empty_bucket_count, 
		ps.avg_chain_length, ps.max_chain_length, ps.scans_started, ps.scans_retries, ps.rows_returned, 
		ps.rows_touched, si.KeyCols, si.KeyColsOrdered, si.IncludedCols, si.IncludedColsOrdered,
		si.AllColsOrdered, si.is_unique, si.[index_type], si.[type_desc], si.is_primary_key, si.is_unique_constraint,
		si.is_padded, si.has_filter, si.filter_definition, si.is_disabled, si.[KeyCols_data_length_bytes]	
	FROM #tmpHashIxs AS si
		LEFT JOIN #tmpXIS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id]
	ORDER BY database_name, [table_name], index_id
	OPTION (MAXDOP 2);

	INSERT INTO #tmpAggXTPNC
	SELECT ISNULL(ps.database_id, si.[database_id]), si.database_name, ISNULL(ps.[object_id], si.[object_id]),
		si.[schema_name], si.table_name, si.index_id, si.index_name, ps.delta_pages, ps.internal_pages, 
		ps.leaf_pages, ps.page_update_count, ps.page_update_retry_count, 
		ps.page_consolidation_count, ps.page_consolidation_retry_count, ps.page_split_count, 
		ps.page_split_retry_count, ps.key_split_count, ps.key_split_retry_count, ps.page_merge_count, 
		ps.page_merge_retry_count, ps.key_merge_count, ps.key_merge_retry_count,
		ps.scans_started, ps.scans_retries, ps.rows_returned, ps.rows_touched,
		si.KeyCols, si.KeyColsOrdered, si.IncludedCols, si.IncludedColsOrdered, si.AllColsOrdered,
		si.is_unique, si.[index_type], si.[type_desc], si.is_primary_key, si.is_unique_constraint,
		si.is_padded, si.has_filter, si.filter_definition, si.is_disabled, si.[KeyCols_data_length_bytes]	
	FROM #tmpHashIxs AS si
		LEFT JOIN #tmpXNCIS AS ps ON si.database_id = ps.database_id AND si.index_id = ps.index_id AND si.[object_id] = ps.[object_id]
	ORDER BY database_name, [table_name], index_id
	OPTION (MAXDOP 2);
END;

RAISERROR (N'Output index information', 10, 1) WITH NOWAIT

-- All index information
SELECT 'All_IX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
	[partition_number], fragmentation, fill_factor, [page_count], [size_MB], record_count, range_scan_count, singleton_lookup_count, row_lock_count, row_lock_wait_count,
	row_lock_pct, row_lock_wait_in_ms, [avg_row_lock_waits_in_ms], page_lock_count, page_lock_wait_count,
	page_lock_pct, page_lock_wait_in_ms, [avg_page_lock_waits_in_ms], page_io_latch_wait_in_ms, [avg_page_io_latch_wait_in_ms], [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	user_updates, last_user_seek, last_user_scan, last_user_lookup, last_user_update, KeyCols, IncludedCols,
	is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, filter_definition, KeyCols_data_length_bytes
FROM #tmpAgg
WHERE index_id > 0 -- ignore heaps
ORDER BY [database_name], [schema_name], table_name, [page_count] DESC, forwarded_record_count DESC;

-- All XTP index information
IF @sqlmajorver >= 12
BEGIN
	SELECT 'All_XTP_HashIX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
		total_bucket_count, empty_bucket_count, FLOOR((CAST(empty_bucket_count AS FLOAT)/total_bucket_count) * 100) AS [empty_bucket_pct], avg_chain_length, max_chain_length, 
		scans_started, scans_retries, rows_returned, rows_touched, KeyCols, IncludedCols, is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, 
		filter_definition, KeyCols_data_length_bytes
	FROM #tmpAggXTPHash
	ORDER BY [database_name], [schema_name], table_name, [total_bucket_count] DESC;

	SELECT 'All_XTP_RangeIX_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type,
		delta_pages, internal_pages, leaf_pages, page_update_count, page_update_count, page_update_retry_count, page_consolidation_count, page_consolidation_retry_count, 
		page_split_count, page_split_retry_count, key_split_count, key_split_retry_count, page_merge_count, page_merge_retry_count, key_merge_count, key_merge_retry_count,
		scans_started, scans_retries, rows_returned, rows_touched, KeyCols, IncludedCols, is_unique, is_primary_key, is_unique_constraint, is_disabled, is_padded, has_filter, 
		filter_definition, KeyCols_data_length_bytes
	FROM #tmpAggXTPNC
	ORDER BY [database_name], [schema_name], table_name, [leaf_pages] DESC;
END;

-- All Heaps information
SELECT 'All_Heaps_Info' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [type_desc] AS index_type,
	[partition_number], fragmentation, [page_count], [size_MB], record_count, forwarded_record_count, forwarded_fetch_count,
	range_scan_count, singleton_lookup_count, row_lock_count, row_lock_wait_count,
	row_lock_pct, row_lock_wait_in_ms, [avg_row_lock_waits_in_ms], page_lock_count, page_lock_wait_count,
	page_lock_pct, page_lock_wait_in_ms, [avg_page_lock_waits_in_ms], page_io_latch_wait_in_ms, [avg_page_io_latch_wait_in_ms]
FROM #tmpAgg
WHERE index_id = 0 -- only heaps
ORDER BY [database_name], [schema_name], table_name, [page_count] DESC, forwarded_record_count DESC;

-- Unused indexes that can possibly be dropped or disabled
SELECT 'Unused_IX_With_Updates' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] = 0 
	AND last_user_update > 0
	AND type IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
UNION ALL
SELECT 'Unused_IX_No_Updates' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] = 0 
	AND (last_user_update = 0 OR last_user_update IS NULL)
	AND type IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
ORDER BY [table_name], user_updates DESC, [page_count] DESC;

-- Rarely used indexes that can possibly be dropped or disabled
SELECT 'Rarely_Used_IX' AS [Category], [database_id], [database_name], [object_id], [schema_name], [table_name], [index_id], [index_name], [type_desc] AS index_type, [Hits],
	CONVERT(NVARCHAR,[Reads_Ratio]) COLLATE database_default + '/' + CONVERT(NVARCHAR,[Writes_Ratio]) COLLATE database_default AS [R/W_Ratio],
	[page_count], [size_MB], record_count, user_updates, last_user_seek, last_user_scan, 
	last_user_lookup, last_user_update, is_unique, is_padded, has_filter, filter_definition
FROM #tmpAgg
WHERE [Hits] > 0 AND [Reads_Ratio] < 5
	AND type IN (2,6)				-- non-clustered and non-clustered columnstore indexes only
	AND is_primary_key = 0			-- no primary keys
	AND is_unique_constraint = 0	-- no unique constraints
	AND is_unique = 0 				-- no alternate keys
ORDER BY [database_name], [table_name], [page_count] DESC;

-- Duplicate Indexes
SELECT 'Duplicate_IX' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition, 
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.type IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.type IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

/*
Note that it is possible that a clustered index (unique or not) is among the duplicate indexes to be dropped, 
namely if a non-clustered primary key exists on the table.
In this case, make the appropriate changes in the clustered index (making it unique and/or primary key in this case),
and drop the non-clustered instead.
*/
SELECT 'Duplicate_IX_toDrop' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition, 
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.[index_id] NOT IN (
			SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
			))
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

RAISERROR (N'Starting index search in sql modules...', 10, 1) WITH NOWAIT

DECLARE Dup_Stats CURSOR FAST_FORWARD FOR SELECT I.database_name,I.[index_name] 
FROM #tmpAgg I INNER JOIN #tmpAgg I2
	ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
	AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.[index_id] NOT IN (
			SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
			(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
			WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
				AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
			GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
			))
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[index_id];

OPEN Dup_Stats
FETCH NEXT FROM Dup_Stats INTO @DatabaseName,@indexName
WHILE (@@FETCH_STATUS = 0)
BEGIN
	SET @sqlcmd = 'USE [' + @DatabaseName + '];
SELECT ''' + @DatabaseName + ''' AS [database_name], ss.name AS [schema_name], so.name AS [table_name], ''' + @indexName + ''' AS [index_name], so.type_desc
FROM sys.sql_modules sm
INNER JOIN sys.objects so ON sm.[object_id] = so.[object_id]
INNER JOIN sys.schemas ss ON ss.[schema_id] = so.[schema_id]
WHERE sm.[definition] LIKE ''%' + @indexName + '%'''

	INSERT INTO #tblCode
	EXECUTE sp_executesql @sqlcmd

	FETCH NEXT FROM Dup_Stats INTO @DatabaseName,@indexName
END
CLOSE Dup_Stats
DEALLOCATE Dup_Stats

RAISERROR (N'Ended index search in sql modules', 10, 1) WITH NOWAIT

SELECT 'Duplicate_Indexes_HardCoded' AS [Category], [DatabaseName], [schemaName], [objectName] AS [referedIn_objectName], 
	indexName AS [referenced_indexName], type_desc AS [refered_objectType]
FROM #tblCode
ORDER BY [DatabaseName], [objectName];

-- Redundant Indexes
SELECT 'Redundant_IX' AS [Category], I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[type_desc] AS index_type, I.is_unique, I.is_padded, I.has_filter, I.filter_definition,
	I.[Hits], I.[KeyCols], I.IncludedCols, CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END AS [AllColsOrdered]
FROM #tmpAgg I INNER JOIN #tmpAgg I2
ON I.[database_id] = I2.[database_id] AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
	AND (((I.[KeyColsOrdered] <> I2.[KeyColsOrdered] OR I.IncludedColsOrdered <> I2.IncludedColsOrdered)
		AND ((CASE WHEN I.IncludedColsOrdered IS NULL THEN I.[KeyColsOrdered] ELSE I.[KeyColsOrdered] + ',' + I.IncludedColsOrdered END) = (CASE WHEN I2.IncludedColsOrdered IS NULL THEN I2.[KeyColsOrdered] ELSE I2.[KeyColsOrdered] + ',' + I2.IncludedColsOrdered END)
			OR I.[AllColsOrdered] = I2.[AllColsOrdered]))
	OR (I.[KeyColsOrdered] <> I2.[KeyColsOrdered] AND I.IncludedColsOrdered = I2.IncludedColsOrdered)
	OR (I.[KeyColsOrdered] = I2.[KeyColsOrdered] AND I.IncludedColsOrdered <> I2.IncludedColsOrdered)
	OR ((I.[AllColsOrdered] = I2.[AllColsOrdered] AND I.filter_definition IS NULL AND I2.filter_definition IS NOT NULL) OR (I.[AllColsOrdered] = I2.[AllColsOrdered] AND I.filter_definition IS NOT NULL AND I2.filter_definition IS NULL)))
	AND I.[index_id] NOT IN (SELECT I3.[index_id]
		FROM #tmpIxs I3 INNER JOIN #tmpIxs I4
		ON I3.[database_id] = I4.[database_id] AND I3.[object_id] = I4.[object_id] AND I3.[index_id] <> I4.[index_id] 
			AND I3.[KeyCols] = I4.[KeyCols] AND (I3.IncludedCols = I4.IncludedCols OR (I3.IncludedCols IS NULL AND I4.IncludedCols IS NULL))
		WHERE I3.[database_id] = I.[database_id] AND I3.[object_id] = I.[object_id]
		GROUP BY I3.[index_id])
WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
	AND I.is_unique_constraint = 0	-- no unique constraints
	AND I2.is_unique_constraint = 0	-- no unique constraints
GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_unique, I.is_padded, I.has_filter, I.filter_definition
ORDER BY I.database_name, I.[table_name], I.[AllColsOrdered], I.[index_id];

-- Large IX Keys
SELECT 'Large_Index_Key' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], 
	I.KeyCols, [KeyCols_data_length_bytes]
FROM #tmpAgg I
WHERE [KeyCols_data_length_bytes] > 900
ORDER BY I.[database_name], I.[schema_name], I.[table_name], I.[index_id];

-- Low Fill Factor
SELECT 'Low_Fill_Factor' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], 
	[fill_factor], I.KeyCols, I.IncludedCols, CASE WHEN I.IncludedCols IS NULL THEN I.[KeyCols] ELSE I.[KeyCols] + ',' + I.IncludedCols END AS [AllColsOrdered]
FROM #tmpAgg I
WHERE [fill_factor] BETWEEN 1 AND 79
ORDER BY I.[database_name], I.[schema_name], I.[table_name], I.[index_id];

--NonUnique Clustered IXs
SELECT 'NonUnique_CIXs' AS [Category], I.[database_name], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[KeyCols]
FROM #tmpAgg I
WHERE [is_unique] = 0 
	AND I.[index_id] = 1
ORDER BY I.[database_name], I.[schema_name], I.[table_name];

RAISERROR (N'Generating scripts...', 10, 1) WITH NOWAIT

DECLARE @strSQL NVARCHAR(4000)
PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] = 0 AND last_user_update > 0) > 0
BEGIN
	PRINT CHAR(10) + '--############# Existing unused indexes with updates drop statements #############' + CHAR(10)
	DECLARE Un_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] = 0 AND last_user_update > 0
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC;

	OPEN Un_Stats
	FETCH NEXT FROM Un_Stats INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM Un_Stats INTO @strSQL
	END
	CLOSE Un_Stats
	DEALLOCATE Un_Stats
	PRINT CHAR(10) + '--############# Ended unused indexes with updates drop statements #############' + CHAR(10)
END;

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] = 0 AND (last_user_update = 0 OR last_user_update IS NULL)) > 0
BEGIN
	PRINT CHAR(10) + '--############# Existing unused indexes with no updates drop statements #############' + CHAR(10)
	DECLARE Un_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] = 0 AND (last_user_update = 0 OR last_user_update IS NULL)
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC;

	OPEN Un_Stats
	FETCH NEXT FROM Un_Stats INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM Un_Stats INTO @strSQL
	END
	CLOSE Un_Stats
	DEALLOCATE Un_Stats
	PRINT CHAR(10) + '--############# Ended unused indexes with no updates drop statements #############' + CHAR(10)
END;

IF (SELECT COUNT(*) FROM #tmpAgg WHERE [Hits] > 0 AND [Reads_Ratio] < 5) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'
	PRINT CHAR(10) + '--############# Existing rarely used indexes drop statements #############' + CHAR(10)
	DECLARE curRarUsed CURSOR FAST_FORWARD FOR SELECT 'USE ' + [database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ [index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME([index_name]) + ' ON ' + QUOTENAME([schema_name]) + '.' + QUOTENAME([table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg
	WHERE [Hits] > 0 AND [Reads_Ratio] < 5
	ORDER BY [database_name], [table_name], [Reads_Ratio] DESC

	OPEN curRarUsed
	FETCH NEXT FROM curRarUsed INTO @strSQL
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		PRINT @strSQL
		FETCH NEXT FROM curRarUsed INTO @strSQL
	END
	CLOSE curRarUsed
	DEALLOCATE curRarUsed
	PRINT '--############# Ended rarely used indexes drop statements #############' + CHAR(10)
END;

PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */'
PRINT CHAR(10) + '/*
NOTE: It is possible that a clustered index (unique or not) is among the duplicate indexes to be dropped, namely if a non-clustered primary key exists on the table.
In this case, make the appropriate changes in the clustered index (making it unique and/or primary key in this case), and drop the non-clustered instead.
*/'
PRINT CHAR(10) + '--############# Existing Duplicate indexes drop statements #############' + CHAR(10)
DECLARE Dup_Stats CURSOR FAST_FORWARD FOR SELECT 'USE ' + I.[database_name] + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sys.indexes WHERE name = N'''+ I.[index_name] + ''')' + CHAR(10) + 'DROP INDEX ' + QUOTENAME(I.[index_name]) + ' ON ' + QUOTENAME(I.[schema_name]) + '.' + QUOTENAME(I.[table_name]) + ';' + CHAR(10) + 'GO' + CHAR(10) 
	FROM #tmpAgg I INNER JOIN #tmpAgg I2
		ON I.database_id = I2.database_id AND I.[object_id] = I2.[object_id] AND I.[index_id] <> I2.[index_id] 
		AND I.[KeyCols] = I2.[KeyCols] AND (I.IncludedCols = I2.IncludedCols OR (I.IncludedCols IS NULL AND I2.IncludedCols IS NULL))
		AND ((I.filter_definition = I2.filter_definition) OR (I.filter_definition IS NULL AND I2.filter_definition IS NULL))
	WHERE I.[type] IN (1,2,5,6)			-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
		AND I2.[type] IN (1,2,5,6)		-- clustered, non-clustered, clustered and non-clustered columnstore indexes only
		AND I.[index_id] NOT IN (
				SELECT COALESCE((SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
					AND (tI3.is_unique = 1 AND tI3.is_primary_key = 1)
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
				(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
					AND (tI3.is_unique = 1 OR tI3.is_primary_key = 1)
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered),
				(SELECT MIN(tI3.[index_id]) FROM #tmpAgg tI3
				WHERE tI3.[database_id] = I.[database_id] AND tI3.[object_id] = I.[object_id] 
					AND tI3.[KeyCols] = I.[KeyCols] AND (tI3.IncludedCols = I.IncludedCols OR (tI3.IncludedCols IS NULL AND I.IncludedCols IS NULL))
				GROUP BY tI3.[object_id], tI3.KeyCols, tI3.IncludedCols, tI3.[KeyColsOrdered], tI3.IncludedColsOrdered)
				))
	GROUP BY I.[database_id], I.[database_name], I.[object_id], I.[schema_name], I.[table_name], I.[index_id], I.[index_name], I.[Hits], I.KeyCols, I.IncludedCols, I.[KeyColsOrdered], I.IncludedColsOrdered, I.type_desc, I.[AllColsOrdered], I.is_primary_key, I.is_unique_constraint, I.is_unique, I.is_padded, I.has_filter, I.filter_definition
	ORDER BY I.database_name, I.[table_name], I.[index_id];
OPEN Dup_Stats
FETCH NEXT FROM Dup_Stats INTO @strSQL
WHILE (@@FETCH_STATUS = 0)
BEGIN
	PRINT @strSQL
	FETCH NEXT FROM Dup_Stats INTO @strSQL
END
CLOSE Dup_Stats
DEALLOCATE Dup_Stats
PRINT '--############# Ended Duplicate indexes drop statements #############' + CHAR(10)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIPS'))
DROP TABLE #tmpIPS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIOS'))
DROP TABLE #tmpIOS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIUS'))
DROP TABLE #tmpIUS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXIS'))
DROP TABLE #tmpXIS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpXNCIS'))
DROP TABLE #tmpXNCIS;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpIxs'))
DROP TABLE #tmpIxs;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpHashIxs'))
DROP TABLE #tmpHashIxs;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAgg'))
DROP TABLE #tmpAgg;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPHash'))
DROP TABLE #tmpAggXTPHash;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tmpAggXTPNC'))
DROP TABLE #tmpAggXTPNC;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblWorking'))
DROP TABLE #tblWorking;
IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#tblCode'))
DROP TABLE #tblCode;
GO
