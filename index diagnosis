 
---spDetectIndexFragmentation
--select db_id()

--CREATE TABLE sqlIndexREBUILD (
--	id int IDENTITY(1,1) NOT NULL PRIMARY KEY,
--	SQLString varchar(200) NOT NULL,
--	Fraglevel Decimal(19,3) NOT NULL,
--)
--GO
--CREATE PROCEDURE dbo.spDetectIndexFragmentation
--AS
--
--INSERT INTO sqlIndexRebuild (SQLString, FragLevel)
SELECT DISTINCT
	SQL_Reorg = 'ALTER INDEX ALL ON ' + x.dbname + '.' + x.schemaname + '.' + x.[table] + ' REORGANIZE' + CHAR(10)+ CHAR(13)+'GO'
,	SQL_Status = 'UPDATE STATISTICS ' + x.dbname + '.' + x.schemaname + '.' + x.[table]  + CHAR(10)+ CHAR(13)+'GO'
,	SQL_Rebuild = 'ALTER INDEX ALL ON ' + x.dbname + '.' + x.schemaname + '.' + x.[table] + ' REBUILD ' + CHAR(10)+ CHAR(13)+'GO'
--,	FragLevel	=	sum(FragLevel)
,	avg_fragmentation_in_percent	=	avg(avg_fragmentation_in_percent)
,	page_count	=	sum(page_count)
--, * 
FROM 
(
select 
	--[fraglevel] = (power(s.avg_fragmentation_in_percent,2) *page_count)/power(10,7),
	avg_fragmentation_in_percent = s.avg_fragmentation_in_percent
,	page_count = page_count
,	dbname		= db_name(s.database_id)
,	[table]		= o.name
,	schemaname	= sc.name
--, index_name = i.name, s.index_type_desc, alloc_unit_type_desc, s.avg_fragmentation_in_percent, page_count, fragment_count, avg_fragment_size_in_pages
--select *
from sys.dm_db_index_physical_stats (DB_ID(),null,null, null,'limited') s
inner join --select * from
sys.indexes i on s.object_id = i.object_id and s.index_id = i.index_id
inner join  --select * from
sys.objects o on o.object_id = s.object_id
inner join --select * from
sys.schemas sc
on o.schema_id = sc.schema_id

WHERE 
		i.is_disabled = 0
and		i.type_desc = 'CLUSTERED'
and		s.database_id = db_id()
and		alloc_unit_Type_desc <> 'LOB_DATA'
and page_count > 1000

) x
WHERE avg_fragmentation_in_percent > 70
group by x.dbname , x.schemaname , x.[table]
order by page_count desc, avg_fragmentation_in_percent desc

GO




--index ALLOW_PAGE_LOCKS
select 'alter INDEX [' + i.name + '] ON [' + s.name + '].[' + o.name + '] SET (ALLOW_PAGE_LOCKS = ON) --this is default'
, * from sys.indexes i
inner join sys.objects o on i.object_id  = o.object_id
inner join sys.schemas s on s.schema_id = o.schema_id
where allow_page_locks = 0
and o.is_ms_shipped = 0


-----------------------------------------------------------------------------------------------------------------------

--Index/partitions in current database
select SizeMb= (p.in_row_reserved_page_count*8.)/1024.
,	indexname = i.name
,	tablename = '[' + s.name + '].[' + o.name + ']'
,	pr.data_compression_desc
,	p.partition_number
,  rebuildcompress = 
CASE WHEN pr.data_compression_desc = 'columnstore' THEN NULL ELSE
	'ALTER INDEX [' + i.name + '] ON [' + s.name + '].[' + o.name + '] REBUILD ' + 
	CASE WHEN MAX(p.partition_number) OVER (PARTITION by i.name)  > 1 THEN 
	'PARTITION = ' + cast(p.partition_number as varchar(5)) ELSE ''  END +
	' WITH (SORT_IN_TEMPDB = ON
	, DATA_COMPRESSION = PAGE) ' + CHAR(10) + CHAR(13)
END
, *
from sys.dm_db_partition_stats p
inner join sys.partitions pr on p.partition_id = pr.partition_id
inner join sys.objects o on p.object_id = o.object_id 
inner join sys.schemas s on s.schema_id = o.schema_id
left outer join sys.indexes i on i.object_id = o.object_id and i.index_id = p.index_id
WHERE o.is_ms_shipped = 0

order by SizeMb desc



-----------------------------------------------------------------------------------------------------------------------
select 
	[Database Name] = db_name()
,	[Table Name]	= s.name + '.' + o.name
,	[Column Name]	= c.name
,	[Total_rows]	= sum(ps.row_count) 
--Review the distribution of the data in the table
,	[TSQL_Testing_Row_Distribution]	= 'select [' + c.name + '], count(1) from ['+ s.name + '].[' + o.name+'] group by [' + c.name + ']' 
from 
	sys.objects  o
inner join 
	sys.schemas s
	on o.schema_id = s.schema_id
inner join 
	sys.dm_db_partition_stats ps
	on ps.object_id = o.object_id
	and index_id <= 1 --heap or cluster index, ignore NC indexes

left outer join 
	sys.columns c on c.object_id = o.object_id 
left outer join 
	sys.types t on c.user_type_id = t.user_type_id
WHERE 
	o.name <> 'dtproperties'
and is_ms_shipped = 0
and o.type = 'u'
and (	c.name like 'is%' 
	or	c.name like '%active%' 
	or	c.name like '%ignore%' 
	or	c.name like 'has%'
	or	c.name like '%current%' 
	or	c.name like '%archived%' 
	or	c.name like '%flag%' 
	or	c.name like '%bit%' 
	or	t.name = 'bit' 
	--Add any more known naming conventions here
	)	
group by c.name, s.name, o.name
having sum(ps.row_count) > 100000
order by [Total_rows] desc
go

--Existing filtered indexes
SELECT 
	[Database Name] = db_name()
,	[Table Name]	= s.name + '.' + o.name
,	[Index Name]	= i.name
from 
	sys.objects  o
inner join 
	sys.schemas s
	on o.schema_id = s.schema_id
inner join 
	sys.indexes i
	on i.object_id = o.object_id
inner join 
	sys.dm_db_partition_stats ps
	on ps.object_id = o.object_id and ps.index_id = i.index_id
WHERE
	i.has_filter = 1
ORDER BY
	s.name, o.name, i.name


/*
--Potential Filtered index opportunities
select iscurrentphase, count(1) from RepairOrderRepairPhases group by IsCurrentPhase
select isEnabled, count(1) from dbo.Users group by IsEnabled
select [ISPUBLIC], count(1) from [dbo].[TNOTE] group by [ISPUBLIC]
--Potential filtered index
CREATE INDEX IDX_NC_F_Testing on dbo.testtable (Whatever1, whatever2) INCLUDE (whatever3)
WHERE IsActive = 1;
*/

---------------------------------------------------------------------------------------------------------------------
--Finds objects to drop that the Database Tuning Advisor (DTA) leaves behind when it inevitably crashes.

SELECT 'drop index [' + i.name+ '] on [' + schema_name(o.schema_id) + '].[' + object_name(i.[object_id]) + ']'
FROM sys.indexes i
INNER JOIN sys.objects o
ON i.object_id = o.object_id
WHERE 1=1 
and o.is_ms_shipped = 0
and o.type = 'u'
and i.name is not null
and i.is_hypothetical = 1 

select 'drop statistics [' + schema_name(o.schema_id) + '].[' + object_name(i.[object_id]) + '].['+ i.[name] + ']'
FROM sys.stats i
inner join sys.objects o 
on i.object_id = o.object_id 
WHERE 1=1
and o.is_ms_shipped = 0
and o.type = 'u'
and i.[name] LIKE '_dta%' 

---------------------------------------------------------------------------------------------------------------------
--Find duplicate indexes based on keysets and properties

SELECT TableName, IndexName1, IndexName2
, Idx_counter, Idx_first_counter, Keyset_counter, SizeMb
,  [Drop_TSQL] = CASE	WHEN y.Idx_counter > 1 and Idx_first_counter = 1 
	THEN 'IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N''' + TableName + ''') AND name = N''' + IndexName1 + ''')
							DROP INDEX [' + IndexName1 + '] ON ' + TableName + ';' 
	ELSE '' END
FROM (
	SELECT  TableName, IndexName1, IndexName2, SizeMb
		,	Idx_counter = row_number() OVER (PARTITION BY TableName, IndexDefinition1 order by IndexName1, IndexName2)
		,	Idx_first_counter = row_number() OVER (PARTITION BY IndexName1 ORDER BY IndexName1, TableName)
		,	Keyset_counter = dense_rank() OVER ( ORDER BY IndexDefinition1)
		FROM (
			SELECT 
			  TableName = '[' + sc.name + '].[' + o.name + ']'
			, IndexName1 = i1.name, IndexName2 = i2.name
			, IndexDefinition1= (select tablename = object_name(ic.object_id), --indexname = i.name, 
					columnname = c.name,  is_descending_key = ic.is_descending_key, i.type_desc, is_included_column = ic.is_included_column, is_primary_key = i.is_primary_key, is_unique = i.is_unique, has_filter = i.has_filter, filter_definition  = isnull(filter_definition,'') from sys.index_columns ic
					inner join sys.indexes i on i.index_id = ic.index_id and i.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i1.index_id and ic.object_id = o.object_id and i.index_id > 1
					FOR XML AUTO) 
			, IndexDefinition2= (select tablename = object_name(ic.object_id), --indexname = i.name, 
					columnname = c.name, is_descending_key = ic.is_descending_key, i.type_desc, is_included_column = ic.is_included_column, is_primary_key = i.is_primary_key, is_unique = i.is_unique, has_filter = i.has_filter, filter_definition  = isnull(filter_definition,'') from sys.index_columns ic
					inner join sys.indexes i on i.index_id = ic.index_id and i.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i2.index_id and ic.object_id = o.object_id and i.index_id > 1
					FOR XML AUTO)
			, SizeMb= (p.in_row_reserved_page_count*8.)/1024.
			from sys.indexes i1 
			inner join sys.indexes i2
			on i1.object_id  = i2.object_id 
			inner join sys.objects o 
			on i1.object_id = o.object_id
			inner join sys.schemas sc
			on sc.schema_id = o.schema_id
			inner join sys.dm_db_partition_stats p
			on p.object_id = o.object_id
			and p.index_id = i1.index_id 
			WHERE 
				i1.name <> i2.name
			and i1.index_id <> i2.index_id
			and (
				UPPER(i1.name) = UPPER(i2.name) 
				or 
				(
					(select tablename = object_name(ic.object_id), columnname = c.name, si.type_desc, is_descending_key = ic.is_descending_key, is_included_column = ic.is_included_column, is_primary_key = si.is_primary_key, is_unique = si.is_unique, has_filter = si.has_filter, filter_definition  = isnull(filter_definition,'')
					from sys.index_columns ic
					inner join sys.indexes si on si.index_id = ic.index_id and si.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i1.index_id and ic.object_id = o.object_id and si.index_id > 1
					FOR XML AUTO)
					= 
					(select tablename = object_name(ic.object_id), columnname = c.name, si.type_desc, is_descending_key = ic.is_descending_key, is_included_column = ic.is_included_column, is_primary_key = si.is_primary_key, is_unique = si.is_unique, has_filter = si.has_filter, filter_definition  = isnull(filter_definition,'')
					from sys.index_columns ic
					inner join sys.indexes si on si.index_id = ic.index_id and si.object_id = ic.object_id 
					inner join sys.columns c on ic.object_id = c.object_id and ic.column_id = c.column_id 
					where ic.index_id = i2.index_id and ic.object_id = o.object_id and si.index_id > 1
					FOR XML AUTO)
				)
			)
	) x
) y

ORDER BY TableName, IndexName1, IndexName2


/*
IF EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[bAPPH]') AND name = N'biAPPHUniqueAttchID')
			DROP INDEX [biAPPHUniqueAttchID] ON [dbo].[bAPPH];
*/


----------------------------------------------------------------------------------------------------------------------


--Identify if fulltext catalog feature is installed
--Skip this step in Azure SQL DB
IF (SELECT FullText_Indexing_Is_Installed = fulltextserviceproperty('IsFullTextInstalled')) <> 1
BEGIN
	THROW 51000, 'Full text indexing is not installed.',0;
END;
GO

--Identify databases with a fulltext catalog present
--Skip this step in Azure SQL DB
EXEC sp_MSforeachdb 'use[?]; select Database_name = DB_Name(), fc.name from sys.fulltext_catalogs fc'
GO

SELECT	
		Fulltext_Catalog	= c.name
    ,	Table_Name	= o.name
    ,	Key_Index	= i.name
	,   Catalog_Populate_Status = FULLTEXTCATALOGPROPERTY(c.name,'PopulateStatus')
	,	Catalog_Populate_Status_Desc = 
			(SELECT CASE FULLTEXTCATALOGPROPERTY(c.name,'PopulateStatus')
						WHEN 0 THEN 'Idle' --caught up and keeping up
						WHEN 1 THEN 'Full Population In Progress' --initial status upon creation
						WHEN 2 THEN 'Paused'--PROBLEM?
						WHEN 3 THEN 'Throttled'
						WHEN 4 THEN 'Recovering'--PROBLEM
						WHEN 5 THEN 'Shutdown'--PROBLEM
						WHEN 6 THEN 'Incremental Population In Progress'
						WHEN 7 THEN 'Building Index'
						WHEN 8 THEN 'Disk Full.  Paused.' --PROBLEM
						WHEN 9 THEN 'Change Tracking' --expected when it is catching up and not up to date yet
					END) --https://docs.microsoft.com/en-us/sql/t-sql/functions/fulltextcatalogproperty-transact-sql
	,	LastCrawlStart	= fi.crawl_start_date
	,	LastCrawlEnd	= fi.crawl_end_date --null when currently crawling
	,	fi.is_enabled 
	,	c.is_default 
	,	fi.crawl_type_desc
    ,	fi.change_tracking_state_desc
	,	fi.has_crawl_completed
	,	c.is_importing -- Indicates whether the full-text catalog is being imported: 1 = The catalog is being imported. 2 = The catalog is not being imported.
	
FROM	sys.fulltext_catalogs c	
    LEFT OUTER JOIN sys.fulltext_indexes fi ON fi.fulltext_catalog_id = c.fulltext_catalog_id
	LEFT OUTER JOIN sys.objects o			ON o.[object_id] = fi.[object_id] 
    LEFT OUTER JOIN sys.indexes i			ON fi.unique_index_id = i.index_id AND fi.[object_id] = i.[object_id]
/*
WHERE  (fi.crawl_end_date is null --is currently crawling
  or fi.crawl_end_date < dateadd(day, -1, getdate())) --look for any ft index that hasn't updated recently
*/
ORDER	BY c.name, o.name, i.name, fi.crawl_start_date;

--------------------------------------------------------------------------------------------------------------------------
--index_usage_stats
--Discover indexes that aren't helping reads but still hurting writes
--Does not show tables that have never been written to

SELECT  DatabaseName		= d.name
	,	s.object_id
	,	TableName 			= ' [' + sc.name + '].[' + o.name + ']'
    ,   IndexName			= i.name
    ,   s.user_seeks
    ,   s.user_scans
    ,   s.user_lookups
    ,   s.user_updates
	,	ps.row_count
	,	SizeMb				= cast((ps.in_row_reserved_page_count*8.)/1024. as decimal(19,2))
	,	s.last_user_lookup
	,	s.last_user_scan
	,	s.last_user_seek
	,	s.last_user_update
	,	Partition_Schema_Name = psch.[name]
	,	Partition_Number = pr.partition_number
	,	[tSQL]	= '--caution! DROP INDEX [' + i.name + '] ON [' + sc.name + '].[' + o.name + ']' --caution!!
--select object_name(object_id), * 
FROM	sys.dm_db_index_usage_stats s 
        INNER JOIN sys.objects o
			 ON o.object_id=s.object_id
		inner join sys.schemas sc
			on sc.schema_id = o.schema_id
		INNER JOIN sys.indexes i
           ON i.object_id = s.object_id
              AND i.index_id = s.index_id
		left outer join sys.partitions pr 
			on pr.object_id = i.object_id 
			and pr.index_id = i.index_id
		left outer join sys.dm_db_partition_stats ps
			on ps.object_id = i.object_id
			and ps.partition_id = pr.partition_id
		left outer join sys.partition_schemes psch 
			on psch.data_space_id = i.data_space_id
		inner join sys.databases d
			on s.database_id = d.database_id
			and db_name() = d.name
WHERE 1=1 
--Strongly recommended filters
and o.is_ms_shipped = 0
and o.type_desc = 'USER_TABLE'
and i.type_desc = 'NONCLUSTERED'
and is_unique = 0
and is_primary_key = 0
and is_unique_constraint = 0

--Optional filters
--and user_updates / 50. > (user_seeks + user_scans + user_lookups ) --arbitrary
--and o.name in ('ContactBase')
--and o.name not like '%cascade%'
--and (ps.in_row_reserved_page_count) > 1280 --10mb

order by user_seeks + user_scans + user_lookups  asc,  s.user_updates desc; --most useless indexes show up first


SELECT servicename, status_desc, last_startup_time FROM sys.dm_server_services;
GO

-------------------------------------------------------------------------------------------------------------------------

---missing indexes
--Execute this version of the script for the current desired database context only.
--Look below for an all-databases version that cannot build the CREATE statement.
--Demo lab script to generate a missing index suggestion: toolbox\lab - missing index setup demo.sql

SELECT 
	mid.statement 
/* --This block SQL 2017+ only
,	create_index_statement_2017 =	'CREATE NONCLUSTERED INDEX IDX_NC_' + replace(t.name, ' ' ,'')
	+ TRANSLATE(ISNULL(replace(mid.equality_columns, ' ' ,''),'') , '],[' ,' _ ') --Translate is only supported for SQL 2017+
	+ TRANSLATE(ISNULL(replace(mid.inequality_columns, ' ' ,''),''), '],[' ,' _ ')
	+ ' ON ' + statement 
	+ ' (' + ISNULL (mid.equality_columns,'') 
    + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ', ' ELSE '' END 
    + ISNULL (mid.inequality_columns, '')
	+ ')' 
	+ ISNULL (' INCLUDE (' + mid.included_columns + ')', '')  COLLATE SQL_Latin1_General_CP1_CI_AS
	--+ ISNULL (' WITH (ONLINE = ON, SORT_IN_TEMPDB = ON)', '')  COLLATE SQL_Latin1_General_CP1_CI_AS --For SQL Server Enterprise Only
*/

,	create_index_statement	=	'CREATE NONCLUSTERED INDEX IDX_NC_' + replace(t.name, ' ' ,'')
	+ replace(replace(replace(ISNULL(replace(mid.equality_columns, ' ' ,''),'') , '],[' ,'_'),'[','_'),']','') 
	+ replace(replace(replace(ISNULL(replace(mid.inequality_columns, ' ' ,''),''), '],[' ,'_'),'[','_'),']','') 
	+ ' ON ' + statement 
	+ ' (' + ISNULL (mid.equality_columns,'') 
    + CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ', ' ELSE '' END 
    + ISNULL (mid.inequality_columns, '')
	+ ')' 
	+ ISNULL (' INCLUDE (' + mid.included_columns + ')', '')  COLLATE SQL_Latin1_General_CP1_CI_AS
	--+ ISNULL (' WITH (ONLINE = ON, SORT_IN_TEMPDB = ON)', '')  COLLATE SQL_Latin1_General_CP1_CI_AS --For SQL Server Enterprise Only
,	unique_compiles, migs.user_seeks, migs.user_scans, last_user_seek, migs.avg_total_user_cost, avg_user_impact
, mid.equality_columns,  mid.inequality_columns, mid.included_columns
, quartile
--select *
FROM sys.dm_db_missing_index_groups mig
INNER JOIN 
(select *, quartile = NTILE(4) OVER (ORDER BY avg_total_user_cost asc) from sys.dm_db_missing_index_group_stats) migs 
ON migs.group_handle = mig.index_group_handle
--and migs.quartile = 1 --get only the top 25% of suggestions based on cost.
INNER JOIN sys.dm_db_missing_index_details mid 
ON mig.index_handle = mid.index_handle
inner join sys.tables t 
on t.object_id = mid.object_id
inner join sys.schemas s
on s.schema_id = t.schema_id
WHERE 1=1
and mid.database_id = db_id()
--and		(datediff(week, last_user_seek, getdate())) < 1
--and		migs.unique_compiles > 1
--and		migs.quartile >= 3
--and		migs.user_seeks > 10
--and		migs.avg_user_impact > 75
--and		t.name like '%pt_time_salesorder_ids%'
--order by avg_user_impact * avg_total_user_cost desc;
order by create_index_statement;


SELECT servicename, status_desc, last_startup_time FROM sys.dm_server_services;
GO


/*
--All databases
SELECT 
	mid.statement
,	unique_compiles, migs.user_seeks, migs.user_scans, last_user_seek, migs.avg_total_user_cost
, avg_user_impact, mid.equality_columns,  mid.inequality_columns, mid.included_columns
, quartile
--select *
FROM sys.dm_db_missing_index_groups mig
INNER JOIN 
(select *, quartile = NTILE(5) OVER (ORDER BY avg_total_user_cost asc) from sys.dm_db_missing_index_group_stats) migs 
ON migs.group_handle = mig.index_group_handle
--and migs.quartile = 1 --get only the top 20% of suggestions based on cost.
INNER JOIN sys.dm_db_missing_index_details mid 
ON mig.index_handle = mid.index_handle
WHERE 1=1
--and		(datediff(week, last_user_seek, getdate())) < 1
--and		migs.unique_compiles > 1
--and		migs.quartile >= 3
--and		migs.user_seeks > 10
--and		migs.avg_user_impact > 75
order by avg_user_impact * avg_total_user_cost desc 
*/

-----------------------------------------------------------------------------------------------------------------------


---percentage improvement index

--
-- 2007-10-11 Pedro Lopes (Microsoft) pedro.lopes@microsoft.com (http://aka.ms/sqlinsights/)
--
-- 2008-01-17 Check for possibly redundant indexes in the output.
-- 2009-05-21 Changed index scoring method; Disregards indexes with [Score] < 100000 and [User_Hits_on_Missing_Index] < 99;
-- 2013-03-21 Changed database loop method;
-- 2013-11-10 Added search for redundant indexes in missing indexes;

SET NOCOUNT ON;
SET QUOTED_IDENTIFIER ON;

DECLARE @IC VARCHAR(4000), @ICWI VARCHAR(4000), @editionCheck bit

/* Refer to http://msdn.microsoft.com/en-us/library/ms174396.aspx */	
IF (SELECT SERVERPROPERTY('EditionID')) IN (1804890536, 1872460670, 610778273, -2117995310)	
SET @editionCheck = 1 -- supports enterprise only features
ELSE	
SET @editionCheck = 0; -- does not support enterprise only features

-- Create the helper functions
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_allcols'')) DROP FUNCTION dbo.fn_createindex_allcols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_allcols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle 
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_keycols'')) DROP FUNCTION dbo.fn_createindex_keycols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_keycols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle
		AND (ic.column_usage = ''''EQUALITY'''' OR ic.column_usage = ''''INEQUALITY'''')
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_includedcols'')) DROP FUNCTION dbo.fn_createindex_includedcols')
EXEC ('USE tempdb; EXEC(''
CREATE FUNCTION dbo.fn_createindex_includedcols (@ix_handle int)
RETURNS NVARCHAR(max)
AS
BEGIN
	DECLARE @ReturnCols NVARCHAR(max)
	;WITH ColumnToPivot ([data()]) AS ( 
		SELECT CONVERT(VARCHAR(3),ic.column_id) + N'''','''' 
		FROM sys.dm_db_missing_index_details id 
		CROSS APPLY sys.dm_db_missing_index_columns(id.index_handle) ic
		WHERE id.index_handle = @ix_handle
		AND ic.column_usage = ''''INCLUDE''''
		ORDER BY ic.column_id ASC
		FOR XML PATH(''''''''), TYPE 
		), 
		XmlRawData (CSVString) AS ( 
			SELECT (SELECT [data()] AS InputData 
			FROM ColumnToPivot AS d FOR XML RAW, TYPE).value(''''/row[1]/InputData[1]'''', ''''NVARCHAR(max)'''') AS CSVCol 
		) 
	SELECT @ReturnCols = CASE WHEN LEN(CSVString) <= 1 THEN NULL ELSE LEFT(CSVString, LEN(CSVString)-1) END
	FROM XmlRawData
	RETURN (@ReturnCols)
END'')
')

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexCreation'))
DROP TABLE #IndexCreation
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexCreation'))
CREATE TABLE #IndexCreation (
	[database_id] int,
	DBName VARCHAR(255),
	[Table] VARCHAR(255),
	[ix_handle] int,
	[User_Hits_on_Missing_Index] int,
	[Estimated_Improvement_Percent] DECIMAL(5,2),
	[Avg_Total_User_Cost] int,
	[Unique_Compiles] int,
	[Score] NUMERIC(19,3),
	[KeyCols] VARCHAR(1000),
	[IncludedCols] VARCHAR(4000),
	[Ix_Name] VARCHAR(255),
	[AllCols] NVARCHAR(max),
	[KeyColsOrdered] NVARCHAR(max),
	[IncludedColsOrdered] NVARCHAR(max)
	)

IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexRedundant'))
DROP TABLE #IndexRedundant
IF NOT EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID('tempdb.dbo.#IndexRedundant'))
CREATE TABLE #IndexRedundant (
	DBName VARCHAR(255),
	[Table] VARCHAR(255),
	[Ix_Name] VARCHAR(255),
	[ix_handle] int,
	[KeyCols] VARCHAR(1000),
	[IncludedCols] VARCHAR(4000),
	[Redundant_With] VARCHAR(255)
	)

INSERT INTO #IndexCreation
SELECT i.database_id,
	m.[name],
	RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)) AS [Table],
	i.index_handle AS [ix_handle],
	[User_Hits_on_Missing_Index] = (s.user_seeks + s.user_scans),
	s.avg_user_impact, -- Query cost would reduce by this amount in percentage, on average.
	s.avg_total_user_cost, -- Average cost of the user queries that could be reduced by the index in the group.
	s.unique_compiles, -- Number of compilations and recompilations that would benefit from this missing index group.
	(CONVERT(NUMERIC(19,3), s.user_seeks) + CONVERT(NUMERIC(19,3), s.user_scans)) 
		* CONVERT(NUMERIC(19,3), s.avg_total_user_cost) 
		* CONVERT(NUMERIC(19,3), s.avg_user_impact) AS Score, -- The higher the score, higher is the anticipated improvement for user queries.
	CASE WHEN (i.equality_columns IS NOT NULL AND i.inequality_columns IS NULL) THEN i.equality_columns
			WHEN (i.equality_columns IS NULL AND i.inequality_columns IS NOT NULL) THEN i.inequality_columns
			ELSE i.equality_columns + ',' + i.inequality_columns END AS [KeyCols],
	i.included_columns AS [IncludedCols],
	'IX_' + LEFT(RIGHT(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), LEN(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3))) - (CHARINDEX('.', RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), 1)) - 1),
		LEN(RIGHT(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), LEN(RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3))) - (CHARINDEX('.', RIGHT(i.[statement], LEN(i.[statement]) - (LEN(m.[name]) + 3)), 1)) - 1)) - 1) + '_' + CAST(i.index_handle AS NVARCHAR) AS [Ix_Name],
	tempdb.dbo.fn_createindex_allcols(i.index_handle), 
	tempdb.dbo.fn_createindex_keycols(i.index_handle),
	tempdb.dbo.fn_createindex_includedcols(i.index_handle)
FROM sys.dm_db_missing_index_details i
INNER JOIN master.sys.databases m ON i.database_id = m.database_id
INNER JOIN sys.dm_db_missing_index_groups g ON i.index_handle = g.index_handle
INNER JOIN sys.dm_db_missing_index_group_stats s ON s.group_handle = g.index_group_handle
WHERE i.database_id > 4

INSERT INTO #IndexRedundant
SELECT I.DBName, I.[Table], I.[Ix_Name], i.[ix_handle], I.[KeyCols], I.[IncludedCols], I2.[Ix_Name]
FROM #IndexCreation I 
INNER JOIN #IndexCreation I2 ON I.[database_id] = I2.[database_id] AND I.[Table] = I2.[Table] AND I.[Ix_Name] <> I2.[Ix_Name]
	AND (((I.KeyColsOrdered <> I2.KeyColsOrdered OR I.[IncludedColsOrdered] <> I2.[IncludedColsOrdered])
		AND ((CASE WHEN I.[IncludedColsOrdered] IS NULL THEN I.KeyColsOrdered ELSE I.KeyColsOrdered + ',' + I.[IncludedColsOrdered] END) = (CASE WHEN I2.[IncludedColsOrdered] IS NULL THEN I2.KeyColsOrdered ELSE I2.KeyColsOrdered + ',' + I2.[IncludedColsOrdered] END)
			OR I.[AllCols] = I2.[AllCols]))
	OR (I.KeyColsOrdered <> I2.KeyColsOrdered AND I.[IncludedColsOrdered] = I2.[IncludedColsOrdered])
	OR (I.KeyColsOrdered = I2.KeyColsOrdered AND I.[IncludedColsOrdered] <> I2.[IncludedColsOrdered]))
WHERE I.[Score] >= 100000
	AND I2.[Score] >= 100000
GROUP BY I.DBName, I.[Table], I.[Ix_Name], I.[ix_handle], I.[KeyCols], I.[IncludedCols], I2.[Ix_Name]
ORDER BY I.DBName, I.[Table], I.[Ix_Name]

IF (SELECT COUNT(*) FROM #IndexCreation WHERE [Score] >= 100000) > 0
BEGIN
	SELECT 'Missing_Indexes' AS [Information], IC.DBName AS [Database_Name], IC.[Table] AS [Table_Name], CONVERT(bigint,[Score]) AS [Score], [User_Hits_on_Missing_Index], 
		[Estimated_Improvement_Percent], [Avg_Total_User_Cost], [Unique_Compiles], IC.[KeyCols], IC.[IncludedCols], IC.[Ix_Name] AS [Index_Name],
		SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
		ORDER BY IR.[Redundant_With]
	FOR XML PATH('')), 2, 8000) AS [Possibly_Redundant_With]
	FROM #IndexCreation IC
	WHERE [Score] >= 100000
	ORDER BY IC.DBName, IC.[Score] DESC, IC.[User_Hits_on_Missing_Index], IC.[Estimated_Improvement_Percent];		

	SELECT DISTINCT 'Possibly_redundant_IXs_in_list' AS Comments, I.DBName AS [Database_Name], I.[Table] AS [Table_Name], 
		I.[Ix_Name] AS [Index_Name], I.[KeyCols], I.[IncludedCols]
	FROM #IndexRedundant I
	ORDER BY I.DBName, I.[Table], I.[Ix_Name]
END
ELSE
BEGIN
	SELECT 'Missing_Indexes' AS [Information], 'None' AS [Comment]
END;

IF (SELECT COUNT(*) FROM #IndexCreation IC WHERE IC.[IncludedCols] IS NULL AND IC.[Score] >= 100000) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */' + CHAR(10)
	PRINT '--############# Indexes creation statements #############' + CHAR(10)
	DECLARE cIC CURSOR FAST_FORWARD FOR
	SELECT '-- User Hits on Missing Index ' + IC.[Ix_Name] + ': ' + CONVERT(VARCHAR(20),IC.[User_Hits_on_Missing_Index]) + CHAR(10) +
		'-- Estimated Improvement Percent: ' + CONVERT(VARCHAR(6),IC.[Estimated_Improvement_Percent]) + CHAR(10) +
		'-- Average Total User Cost: ' + CONVERT(VARCHAR(50),IC.[Avg_Total_User_Cost]) + CHAR(10) +
		'-- Unique Compiles: ' + CONVERT(VARCHAR(50),IC.[Unique_Compiles]) + CHAR(10) +
		'-- Score: ' + CONVERT(VARCHAR(20),CONVERT(bigint,IC.[Score])) + 
		CASE WHEN (SELECT COUNT(IR.[Redundant_With]) FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]) > 0 
		THEN CHAR(10) + '-- Possibly Redundant with Missing Index(es): ' + SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
			FOR XML PATH('')), 2, 8000) 
		ELSE '' END +
		CHAR(10) + 'USE ' + QUOTENAME(IC.DBName) + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sysindexes WHERE name = N''' +
		IC.[Ix_Name] + ''') DROP INDEX ' + IC.[Table] + '.' +
		IC.[Ix_Name] + ';' + CHAR(10) + 'GO' + CHAR(10) + 'CREATE INDEX ' +
		IC.[Ix_Name] + ' ON ' + IC.[Table] + ' (' + IC.[KeyCols] + CASE WHEN @editionCheck = 1 THEN ') WITH (ONLINE = ON);' ELSE ');' END + CHAR(10) + 'GO' + CHAR(10)
	FROM #IndexCreation IC
	WHERE IC.[IncludedCols] IS NULL AND IC.[Score] >= 100000
	ORDER BY IC.DBName, IC.[Table], IC.[Ix_Name]
	OPEN cIC
	FETCH NEXT FROM cIC INTO @IC
	WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @IC
			FETCH NEXT FROM cIC INTO @IC
		END
	CLOSE cIC
	DEALLOCATE cIC
END;

IF (SELECT COUNT(*) FROM #IndexCreation IC WHERE IC.[IncludedCols] IS NOT NULL AND IC.[Score] >= 100000) > 0
BEGIN
	PRINT CHAR(10) + '/* Generated on ' + CONVERT (VARCHAR, GETDATE()) + ' in ' + @@SERVERNAME + ' */' + CHAR(10)
	PRINT '--############# Covering indexes creation statements #############' + CHAR(10)
	DECLARE cICWI CURSOR FAST_FORWARD FOR
	SELECT '-- User Hits on Missing Index ' + IC.[Ix_Name] + ': ' + CONVERT(VARCHAR(20),IC.[User_Hits_on_Missing_Index]) + CHAR(10) +
		'-- Estimated Improvement Percent: ' + CONVERT(VARCHAR(6),IC.[Estimated_Improvement_Percent]) + CHAR(10) +
		'-- Average Total User Cost: ' + CONVERT(VARCHAR(50),IC.[Avg_Total_User_Cost]) + CHAR(10) +
		'-- Unique Compiles: ' + CONVERT(VARCHAR(50),IC.[Unique_Compiles]) + CHAR(10) +
		'-- Score: ' + CONVERT(VARCHAR(20),CONVERT(bigint,IC.[Score])) + 
		CASE WHEN (SELECT COUNT(IR.[Redundant_With]) FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]) > 0 
		THEN CHAR(10) + '-- Possibly Redundant with Missing Index(es): ' + SUBSTRING((SELECT ',' + IR.[Redundant_With] FROM #IndexRedundant IR 
			WHERE IC.DBName = IR.DBName AND IC.[Table] = IR.[Table] AND IC.[ix_handle] = IR.[ix_handle]
			FOR XML PATH('')), 2, 8000) 
		ELSE '' END + 
		CHAR(10) + 'USE ' + QUOTENAME(IC.DBName) + CHAR(10) + 'GO' + CHAR(10) + 'IF EXISTS (SELECT name FROM sysindexes WHERE name = N''' +
		IC.[Ix_Name] + ''') DROP INDEX ' + IC.[Table] + '.' +
		IC.[Ix_Name] + ';' + CHAR(10) + 'GO' + CHAR(10) + 'CREATE INDEX ' +
		IC.[Ix_Name] + ' ON ' + IC.[Table] + ' (' + IC.[KeyCols] + CASE WHEN @editionCheck = 1 THEN ') WITH (ONLINE = ON);' ELSE ');' END + CHAR(10) + 'GO' + CHAR(10)
	FROM #IndexCreation IC
	WHERE IC.[IncludedCols] IS NOT NULL AND IC.[Score] >= 100000
	ORDER BY IC.DBName, IC.[Table], IC.[Ix_Name]
	OPEN cICWI
	FETCH NEXT FROM cICWI INTO @ICWI
	WHILE @@FETCH_STATUS = 0
		BEGIN
			PRINT @ICWI
			FETCH NEXT FROM cICWI INTO @ICWI
		END
	CLOSE cICWI
	DEALLOCATE cICWI
END;

DROP TABLE #IndexCreation
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_keycols'')) DROP FUNCTION dbo.fn_createindex_keycols')
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_allcols'')) DROP FUNCTION dbo.fn_createindex_allcols')
EXEC ('USE tempdb; IF EXISTS (SELECT [object_id] FROM tempdb.sys.objects (NOLOCK) WHERE [object_id] = OBJECT_ID(''tempdb.dbo.fn_createindex_includedcols'')) DROP FUNCTION dbo.fn_createindex_includedcols')
GO
